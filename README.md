# Nftables

## Быстрый старт

1. **Установка**: `sudo dnf install nftables || sudo apt install nftables || sudo yum install nftables`
2. **Развертывание конфигурации**: выполнить все блоки кода из раздела "Конфигурационные файлы"
3. **Настройка под свой сервер**:
   - Отредактировать `/etc/nftables.d/definitions-services.nft` - добавить свои сервисы
   - В том же файле раскомментировать `protected_interfaces` - указать внешние интерфейсы которые защитить от DDOS-атак
4. **Активация**: `systemctl enable --now nftables.service`
5. **Проверка статуса сервиса**: `sudo systemctl status nftables.service`
6. **Проверка что правила загрузились**: `sudo nft list ruleset`

## Краткий справочник по выражениям `nftables`

| Выражение      | Расшифровка                                         | Пример использования          |
| :------------- | :-------------------------------------------------- | :---------------------------- |
| `saddr`        | Source Address (IP-адрес источника)                 | `ip saddr 1.2.3.4 drop`       |
| `daddr`        | Destination Address (IP-адрес назначения)           | `ip daddr 2001:db8::1 accept` |
| `iifname`      | Input Interface Name (имя входящего интерфейса)     | `iifname "eth0"`              |
| `oifname`      | Output Interface Name (имя исходящего интерфейса)   | `oifname "docker0"`           |
| `meta l4proto` | Протокол 4-го уровня (TCP, UDP, ICMP)               | `meta l4proto tcp`            |
| `th dport`     | Transport Header Destination Port (порт назначения) | `tcp dport 443`               |
| `ct state`     | Connection Tracking State (состояние соединения)    | `ct state established accept` |

## Наиболее частые команды

### Временная блокировка трафика

```bash
# Блокирует ВЕСЬ трафик от 1.2.3.4 на 24 часа
# ip4 по дефолту на 24 часа
sudo nft add element inet filter blackhole_ips { 1.2.3.4 }
# ip6
sudo nft add element inet filter blackhole_ips { "2001:db8::dead:beef" }
# Блокируем всю подсеть 10.200.*.* на 3 часа
sudo nft add element inet filter blackhole_ips { 10.200.0.0/16 timeout 3h }

# Блокирует трафик от 1.2.3.4 только на TCP-порт 80 на 1 час.
sudo nft add element inet filter blackhole_services { 1.2.3.4 . tcp . 80 }
# Блокирует трафик от 1.2.3.4 только на TCP-порт 80 на 4 часа.
sudo nft add element inet filter blackhole_services { 1.2.3.4 . tcp . 80 timeout 4h }
sudo nft add element inet filter blackhole_services { 2001:db8::1 . tcp . 80 timeout 10h }

# Удалить из блокировки
sudo nft delete element inet filter blackhole_ips { 1.2.3.4 }
sudo nft delete element inet filter blackhole_services { 1.2.3.4 . tcp . 80 }
```

### Временное открытие доступа

```bash
# Открыть доступ TCP с ip 1.2.3.4 на порт 51820
sudo nft add element inet filter tmp_input_policy { 1.2.3.4 . tcp . 8080 timeout 1h }
# UDP
# Открыть доступ UDP с ip 1.2.3.4 на порт 51820
sudo nft add element inet filter tmp_input_policy { 1.2.3.4 . udp . 51820 }
# Открыть доступ UDP с ip 1.2.3.4 на порты 30000-35000 на 2 дня
sudo nft add element inet filter tmp_input_policy { 1.2.3.4 . udp . 30000-35000 timeout 2d }


# Удаление из временно предоставленного доступа
sudo nft delete element inet filter tmp_input_policy { 1.2.3.4 . udp . 51820 }
```

### Список элементов

```bash
nft list map inet filter input_policy_map
```

### Логирование

prefix - может быть любым, опишите чтобы Вам было понятно.

level warn/info пишут в syslog: warn — /var/log/messages, info — /var/log/debug

#### Включить логирование блокировки входящего трафика из цепочки input

```bash
# Включить логирование блокирования
sudo nft add rule inet filter log_dropped_input counter log prefix "[INPUT:BLOCKED] " level warn
# посмотреть лог:
sudo journalctl -fk | grep "INPUT:BLOCKED"

# Включить логирование блокированных пакетов на 22 порт
sudo nft add rule inet filter log_dropped_input tcp dport 22 counter log prefix "[INPUT-22:BLOCKED] " level warn
# посмотреть лог:
sudo journalctl -fk | grep "INPUT-22:BLOCKED"

# Логируем заблокированные пакеты на порт 22, но ТОЛЬКО от источника 1.2.3.4
sudo nft add rule inet filter log_dropped_input ip saddr 1.2.3.4 tcp dport 22 counter log prefix "[HOST-SSH-BLOCK] " level warn
# посмотреть лог:
sudo journalctl -fk | grep "HOST-SSH-BLOCK"

# Выключить логирование (просто очистить цепочку):
sudo nft flush chain inet filter log_dropped_input
```

#### Включить логирование блокировки входящего трафика из таблицы netdev

```bash
# Включить:
sudo nft add rule netdev ddos log_dropped_netdev counter log prefix "[NETDEV:DROPPED] "
# посмотреть лог:
sudo journalctl -fk | grep "NETDEV:DROPPED"

# Выключить:
sudo nft flush chain netdev ddos log_dropped_netdev
```

#### Включить логирование блокировки исходящего трафика

```bash
# Логирование всего блокируемого исходящего трафика
sudo nft add rule inet filter log_dropped_output counter log prefix "[OUTPUT:BLOCKED] " level warn
# посмотреть лог:
sudo journalctl -fk | grep "OUTPUT:BLOCKED"

# Включить логирование блокированных пакетов на host 10.10.30.5
sudo nft add rule inet filter log_dropped_output tcp daddr 10.10.30.5 counter log prefix "[OUTPUT-10.10.30.5:BLOCKED] " level warn
# посмотреть лог:
sudo journalctl -fk | grep "OUTPUT-10.10.30.5:BLOCKED"

# Выключить:
sudo nft flush chain inet filter log_dropped_output
```

#### Включить логирование блокировки транзитного трафика

```bash
# Включаем логирование заблокированного транзитного трафика
sudo nft add rule inet filter log_dropped_forward counter log prefix "[FORWARD:DROPPED] "
# Пытаемся запустить `apt update` в контейнере и смотрим логи
sudo journalctl -fk | grep "FORWARD:DROPPED"

# Выключить:
sudo nft flush chain inet filter log_dropped_forward
```

## Частые проблемы и решения

### Проверить конфигурацию

```bash
sudo nft --check -f /etc/nftables.conf && echo "OK" || echo "SYNTAX ERROR"
# Показать первые 5 строк
sudo nft --check -f /etc/nftables.conf && echo "OK" || echo "SYNTAX ERROR" | head -5
```

### Сервер не выходит в интернет

- `sudo conntrack -L | grep ESTABLISHED` - если пусто, проблема в output_policy_map.
- Проверьте `output_policy_map` - добавлены ли DNS и NTP серверы?
- Используйте режим аудита для диагностики

### Docker/Kubernetes не работают

- Убедитесь, что применен `forward-services.nft`
- Проверьте имена интерфейсов в правилах

### SSH блокируется после применения правил

- Временно добавьте свой IP в `tmp_input_policy`:

```bash
sudo nft add element inet filter tmp_input_policy { 192.168.1.100 . tcp . 22 timeout 1h }
```

## Мониторинг и диагностика

### Сброс счетчиков

```bash
sudo nft reset counters
```

### Трассировка

```bash
# Трассировка real-time
sudo nft monitor trace
sudo nft monitor trace input
# Трассировка конкретного пакета от 1.2.3.4 к порту 80
sudo nft trace add inet filter input ip saddr 1.2.3.4 tcp dport 80
```

### Просмотр текущих правил со счетчиками пакетов и байт

```bash
sudo nft list ruleset
sudo nft list ruleset | grep "counter packets"
```

### Просмотр логов ядра

```bash
sudo journalctl -k | grep nftables
# real-time
sudo journalctl -k -f | grep nftables
```

### Анализ conntrack

```bash
sudo conntrack -L
sudo conntrack -E
sudo conntrack -C
```

## Политика по выбору и настройке FW (ужесточаем требования принятые на предприятии)

В связи с очень большой и очень тяжело контролируемой (даже не реально) корпоративной сетью, принимаем как данность следующую философию "Zero Trust" и важность Egress Filtering: относимся к Нашим сервисам так, как-будто они предоставляют сервисы в публичном интЕрнете. Отсюда следует, что Мы свои сервисы должны защищать соответственно!

Многие администраторы игнорируют проблему, которая является ключевым элементом по-настоящему многоуровневой защиты (Defense in Depth). Понимание информационных потоков - это высокий показатель компетенций администратора! В нашем подразделении так же ведется работа по настройке контроля исходящего трафика (egress filtering) на FW для каждого сервера.

### Почему это так важно?

**Предотвращение "звонков домой" (C2 Communication):** Если сервер скомпрометирован, вредоносное ПО попытается связаться со своим командным центром. Контроль исходящего трафика может заблокировать эту попытку на корню.

**Остановка утечек данных (Data Exfiltration):** Злоумышленник, получивший доступ к данным, не сможет их просто так отправить на свой сервер, если разрешены только определенные исходящие соединения.

**Предотвращение участия в атаках:** Ваш сервер не сможет быть использован как часть ботнета для атак на другие ресурсы.

**Соблюдение политик:** Вы можете быть уверены, что сервер обращается только к доверенным репозиториям пакетов, серверам времени и т.д.

## Основы Stateful-файрвола: Соединения, порты и "магия" `ct state`

Чтобы эффективно управлять нашим новым файрволом, крайне важно понимать один ключевой принцип: **современный файрвол работает не с отдельными пакетами, а с СОЕДИНЕНИЯМИ/СЕССИЯМИ.**

Этот подход называется "Stateful Firewall" (файрвол с отслеживанием состояния). Наше ядро Linux "помнит" о каждом установленном соединении. Это позволяет нам создавать очень простые и одновременно очень надежные правила.

### Аналогия: Телефонный звонок

Представьте, что наш файрвол — это очень умный секретарь у телефона.

1.  **Инициация соединения:** Кто-то звонит вам. Для секретаря это **новый (`NEW`)** звонок. Он смотрит в свою книгу правил (`input_policy_map`) и проверяет: "Разрешено ли этому абоненту звонить на этот номер?". Если да, он соединяет.
2.  **Ответные пакеты:** Вы начинаете говорить в ответ. Секретарь видит, что это часть **уже установленного (`ESTABLISHED`)** разговора, который он сам только что разрешил. Он не будет снова проверять книгу правил — он просто пропускает ваш голос дальше.
3.  **Завершение:** Кто-то из вас кладет трубку. Секретарь видит это и вычеркивает разговор из своего списка активных.

Наша конфигурация `nftables` работает точно так же.

### "Магия" отслеживания соединений: `ct state`

В ядре Linux есть подсистема `conntrack` (connection tracking), которая и является "памятью" нашего файрвола. Каждый пакет помечается одним из состояний. Самые важные для нас:

- `NEW`: Самый первый пакет нового соединения (тот самый "звонок" от клиента к серверу). **Это самый важный для проверки пакет!** Именно для него мы и пишем наши детальные правила в картах.
- `ESTABLISHED`: Все последующие пакеты в обе стороны в рамках уже разрешенного соединения (тот самый "разговор").
- `RELATED`: Новый пакет, который логически связан с уже существующим соединением. Классический пример — ICMP-сообщение "destination unreachable", которое приходит в ответ на ваш (разрешенный) пакет.
- `INVALID`: "Сломанный" пакет, который не принадлежит ни одному известному соединению. Это почти всегда либо ошибка в сети, либо вредоносная активность. Мы их всегда блокируем.

#### Наше главное правило-автобан: `ct state related,established accept`

Это самое первое и самое важное правило в наших цепочках `input` и `output`. Оно говорит: **"Если пакет является частью уже разрешенного или связанного с ним соединения, немедленно пропустить его и прекратить дальнейшую обработку"**.

**Почему это так важно?** 99% всего трафика — это `ESTABLISHED` пакеты. Это правило работает как "автобан", пропуская их с максимальной скоростью и не заставляя ядро снова и снова проверять их по нашим сложным картам доступа. Это критически важно для производительности.

### Входящие vs. Исходящие порты: Кто начинает разговор?

Теперь самый главный вопрос: почему для одних сервисов мы открываем входящие порты, а для других — исходящие?

**Ответ прост: все зависит от того, КТО является инициатором соединения.**

#### 1. Почему мы открываем ВХОДЯЩИЙ порт 443 для веб-сервера?

- **Роль нашего сервера:** Он — **СЕРВЕР**. Он сидит и ждет, когда к нему обратятся.
- **Кто начинает разговор?** **Клиент** (браузер пользователя).
- **Как это работает:**
  1.  Браузер пользователя отправляет **`NEW`** пакет на IP-адрес нашего сервера, на порт `443`.
  2.  Наш файрвол в цепочке `input` видит этот `NEW` пакет. Он проверяет его по карте `input_policy_map`. Правило `10.0.0.0/8 . tcp . https : accept` срабатывает. Пакет пропускается к веб-серверу. Соединение считается разрешенным.
  3.  Ответ от нашего веб-сервера пользователю — это уже **`ESTABLISHED`** пакет. Он будет автоматически пропущен правилом `ct state established accept` в цепочке `output`. Нам не нужно создавать для этого ответа отдельное правило.

**Вывод:** Мы открываем **входящий** порт для сервиса, который **принимает** соединения от клиентов.

#### 2. Почему мы НЕ открываем ВХОДЯЩИЙ порт 53 (DNS) или 123 (NTP) на обычном сервере?

- **Роль нашего сервера:** Он — **КЛИЕНТ** этих сервисов. Он сам хочет узнать время или IP-адрес, а не предоставлять эту информацию другим.
- **Кто начинает разговор?** **Наш сервер**.
- **Как это работает:**
  1.  Наш сервер хочет синхронизировать время. Он формирует **`NEW`** пакет и отправляет его с нашего сервера на IP-адрес NTP-сервера (например, `10.10.10.2`) на порт `123`.
  2.  Этот исходящий `NEW` пакет попадает в цепочку `output` нашего файрвола. Он проверяется по карте `output_policy_map`. Правило `10.10.10.2 . udp . 123 : accept` срабатывает. Пакет уходит. Соединение считается разрешенным.
  3.  Ответ от NTP-сервера — это **`ESTABLISHED`** пакет, который приходит на наш сервер. Он будет автоматически пропущен правилом `ct state established accept` в цепочке `input`. Нам не нужно открывать входящий порт 123.

**Вывод:** Мы открываем **исходящий** доступ к порту, если наш сервер должен **инициировать** соединение с другим сервесом.

### Итог в виде таблицы

| Сервис                     | Роль нашего сервера                                                    | Кто инициирует соединение? | Какое правило файрвола нужно?                               |
| :------------------------- | :--------------------------------------------------------------------- | :------------------------- | :---------------------------------------------------------- |
| **Веб-сервер (HTTPS)**     | Сервер (предоставляет услугу)                                          | **Клиент** (браузер)       | **Входящее** правило в `input_policy_map` для порта 443     |
| **DNS-клиент**             | Клиент (потребляет услугу)                                             | **Наш сервер**             | **Исходящее** правило в `output_policy_map` для порта 53    |
| **NTP-клиент**             | Клиент (потребляет услугу)                                             | **Наш сервер**             | **Исходящее** правило в `output_policy_map` для порта 123   |
| **Zabbix-агент (active)**  | Клиент (отправляет данные)                                             | **Наш сервер** (агент)     | **Исходящее** правило в `output_policy_map` для порта 10051 |
| **Zabbix-агент (passive)** | Cервер "слушает" порт (предоставляет данные Zabbix-серверу по запросу) | **Zabbix-сервер**          | **Входящее** правило в `input_policy_map` для порта 10050   |

Примеры для распространенных сетевых взаимодействий:
| Роль сервера | Типичные правила input | Типичные правила output |
|-------------|------------------------|-------------------------|
| Веб-сервер | 80, 443 TCP | DNS, NTP, к БД |
| Сервер БД | 5432, 3306 TCP | DNS, NTP, репликация |
| Прокси/балансировщик | 80, 443 TCP | DNS, NTP, к бэкендам |

Понимание этого простого принципа — **"кто начинает разговор?"** — является ключом к правильной и безопасной настройке любого stateful-файрвола.

## Введение в nftables: Современный файрвол для Linux

`nftables` — это современный фреймворк для фильтрации пакетов в ядре Linux, пришедший на смену устаревшей экосистеме `iptables`. Это не просто "новая версия", а полностью переработанная подсистема, созданная для решения проблем производительности, синтаксиса и сложности, присущих `iptables`.

Основная идея `nftables` — предоставить единый, гибкий и высокопроизводительный инструмент для управления всеми аспектами сетевой безопасности, от простой фильтрации на хосте до сложной маршрутизации и NAT. Вместо набора отдельных утилит (`iptables`, `ip6tables`, `arptables`, `ebtables`) теперь есть единый инструмент командной строки — `nft`.

### Почему nftables? Сравнение с iptables, firewalld и ufw

Чтобы понять преимущества `nftables`, важно сравнить его с другими популярными инструментами.

#### `nftables` vs. `iptables` (Прямой конкурент)

| Характеристика         | `iptables`                                                                                                                                                                                                                               | `nftables`                                                                                                                                                                                                                                                              | Преимущество `nftables`                                                                                                     |
| :--------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- |
| **Архитектура**        | Набор отдельных утилит (`iptables`, `ip6tables`, `arptables`) со своей логикой.                                                                                                                                                          | Единый фреймворк и утилита `nft` для всех протоколов.                                                                                                                                                                                                                   | **Простота и консистентность.** Больше не нужно переключаться между разными утилитами для IPv4, IPv6 и ARP.                 |
| **Синтаксис**          | Громоздкий, многословный, часто требует повторения правил.                                                                                                                                                                               | Интуитивно понятный, структурированный, похожий на язык программирования.                                                                                                                                                                                               | **Читаемость и удобство.** Правила легче писать, читать и отлаживать.                                                       |
| **Производительность** | **Низкая.** Правила обрабатываются как длинный **линейный список**. Каждый пакет должен последовательно пройти через множество правил, пока не найдется совпадение. Это сильно замедляет работу при большом количестве правил.           | **Высокая.** Использует современные структуры данных, такие как **хэш-таблицы (`map`) и наборы (`set`)**. Проверка на соответствие в сете или карте — это одна быстрая операция, которая не зависит от количества элементов. Это на порядки быстрее линейного перебора. | **Скорость.** `nftables` значительно производительнее, особенно на высоконагруженных системах и при сложных наборах правил. |
| **Обновление правил**  | **Неатомарное.** Применение нового набора правил происходит путем удаления старых и добавления новых по одному. Существует короткий промежуток времени, когда файрвол находится в неконсистентном состоянии, что может быть небезопасно. | **Атомарное.** Весь набор правил применяется как единая транзакция. Либо вся конфигурация успешно применяется, либо не применяется ничего. Это исключает "гонки состояний" и гарантирует целостность.                                                                   | **Надежность и безопасность.**                                                                                              |

#### `nftables` vs. `firewalld` и `ufw` (Разные уровни абстракции)

Часто возникает путаница, но `nftables` не является прямым конкурентом `firewalld` или `ufw`.

- **`nftables`** — это **низкоуровневый фреймворк** в ядре. Это "двигатель" файрвола.
- **`firewalld` и `ufw`** — это **высокоуровневые утилиты управления** (фронтенды). Это "приборная панель" для управления двигателем.

**firewalld:**

- **Что это:** Мощный демон для управления файрволом, использующий концепцию "зон" (например, `public`, `internal`, `dmz`).
- **Связь с `nftables`:** В современных дистрибутивах (RHEL 8+, Fedora, Debian 11+) `firewalld` по умолчанию использует `nftables` в качестве своего **бэкенда**. Он переводит свои высокоуровневые команды (например, `firewall-cmd --zone=public --add-service=http`) в правила `nftables`.
- **Когда использовать:** Идеально подходит для серверов и рабочих станций, где требуется динамическое управление правилами и простая работа с зонами.

**ufw (Uncomplicated Firewall):**

- **Что это:** Очень простой интерфейс для управления файрволом, созданный для максимального упрощения базовых задач (открыть/закрыть порт).
- **Связь с `nftables`:** Также может использовать `nftables` в качестве бэкенда.
- **Когда использовать:** Идеально подходит для персональных компьютеров или простых серверов, где не требуется сложная логика, а нужна лишь базовая защита.

### Как проверить, что в системе используется `nftables`?

Даже если вы используете команды `iptables`, ваша система, скорее всего, уже переводит их в `nftables`. Самый надежный способ это проверить — посмотреть на версию утилиты `iptables`:

```bash
sudo iptables --version
```

- Если вывод содержит `(nf_tables)` — ваша система использует современный режим совместимости. Все команды `iptables` транслируются в `nftables`.
  ```
  iptables v1.8.7 (nf_tables)
  ```
- Если вывод содержит `(legacy)` — ваша система использует старый `iptables`.
  ```
  iptables v1.8.7 (legacy)
  ```

В большинстве современных дистрибутивов Linux по умолчанию используется `iptables-nft`.

### Архитектура `nftables`: Таблицы и Цепочки

Вся логика в `nftables` строится вокруг иерархии: **Таблица -> Цепочка -> Правило**.

- **Таблица (Table):** Контейнер верхнего уровня, группирующий цепочки по семейству протоколов.
- **Цепочка (Chain):** Контейнер для правил. Бывают двух типов:
  - **Базовые цепочки (Base Chains):** "Прикреплены" к точкам входа (хукам) в сетевом стеке ядра.
  - **Пользовательские цепочки (Regular Chains):** Используются для группировки правил и вызываются из других цепочек (`jump`).

#### Основные таблицы и их базовые цепочки (хуки)

| Семейство / Таблица | Описание                                                                        | Базовые цепочки (точки входа)                             | Назначение цепочек                                                                                                                            |
| :------------------ | :------------------------------------------------------------------------------ | :-------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------- |
| **`arp`**           | Обрабатывает пакеты протокола ARP (L2).                                         | `input`, `output`                                         | Для фильтрации ARP-запросов/ответов.                                                                                                          |
| **`ip`**, **`ip6`** | Обрабатывают только IPv4 или IPv6 соответственно.                               | `prerouting`, `input`, `forward`, `output`, `postrouting` | Раздельное управление трафиком IPv4 и IPv6.                                                                                                   |
| **`inet`**          | **Универсальная.** Обрабатывает и IPv4, и IPv6.                                 | `prerouting`, `input`, `forward`, `output`, `postrouting` | **Рекомендуется использовать** для создания единых правил для обоих протоколов (IPv4 и IPv6).                                                               |
| **`bridge`**        | Обрабатывает трафик, проходящий через мост (L2).                                | `prerouting`, `input`, `forward`, `output`, `postrouting` | Для фильтрации на уровне L2 в виртуализированных средах или на свитчах.                                                                       |
| **`netdev`**        | **Самый ранний уровень.** Обрабатывает трафик на уровне драйвера сетевой карты. | `ingress`                                                 | Для очень ранней отбраковки пакетов еще до того, как они попадут в основной сетевой стек. Максимальная производительность для защиты от DDoS. |

#### Описание базовых цепочек (порядок прохождения пакета)

1.  **`ingress` (Таблица `netdev`):** Самая первая точка входа пакета в систему, сразу на уровне сетевого драйвера.
2.  **`prerouting` (Таблицы `ip`, `inet`):** Пакет вошел в основной сетевой стек, но ядро еще не приняло решение о маршрутизации (не решено, предназначен ли пакет локальному процессу или его нужно переслать дальше).
3.  **Далее пакет идет по одному из двух путей:**
    - **`input` (Таблицы `ip`, `inet`):** Если пакет предназначен для локального процесса на этом сервере.
    - **`forward` (Таблицы `ip`, `inet`):** Если пакет **не предназначен** этому серверу, а должен быть им **перенаправлен (маршрутизирован)** на другой хост. Это ключевая цепочка для серверов, выполняющих роль **роутера, NAT-шлюза или хоста для контейнеров** (Docker, Kubernetes).
4.  **`output` (Таблицы `ip`, `inet`):** Обрабатывает пакеты, которые сгенерированы локальными процессами на самом сервере.
5.  **`postrouting` (Таблицы `ip`, `inet`):** Последняя точка перед отправкой пакета в сеть. Решение о маршрутизации уже принято. Идеальное место для NAT (маскарадинга).

## Создание конфигурационных файлов nftables

### Описание файлов

Конфигурация `nftables` построена по **модульному, централизованному и ролевому принципу**. Она разделяет "данные" (что разрешено), "логику" (как обрабатывается трафик) и "роли" (специфические функции сервера).

**Эти файлы управляются централизованно, должны быть на всех серверах одинаковые, так же возможно их обновление в любое время**. Изменения не должны влиять на предоставляемые сервисы конкретного сервера/ВМ:

- **Главный файл:**
  - `/etc/nftables.conf`: Точка входа, которая собирает все части воедино.
- **Файлы данных ("ЧТО?"):**
  - `/etc/nftables.d/definitions-infra.nft`: **Базовые данные.** Содержит общие для всей инфраструктуры определения (сеты для банов, исключений, общие исходящие правила).
- **Файлы логики ("КАК?"):**
  - `/etc/nftables.d/tables.nft`: **Каркас.** Создает структуру таблиц и базовых цепочек.
  - `/etc/nftables.d/netdev.nft`: **Первый рубеж обороны.** Защита от DDoS и спуфинга.
  - `/etc/nftables.d/mangle.nft`: **Второй рубеж.** Интеллектуальная L4-защита.

      **Эти файлы управляются администраторами сервера/ВМ.**
- **Файлы данных ("ЧТО?"):**
  - `/etc/nftables.d/definitions-services.nft`: **Данные сервиса.** Содержит правила доступа, специфичные для сервисов на **данном конкретном сервере/ВМ**.
- **Файлы логики ("КАК?"):**
  - `/etc/nftables.d/raw-optimizations.nft`: Оптимизация производительности. **Применяется только на нужных серверах с соответствующими сервисами**
- **Файлы ролей ("ДЛЯ ЧЕГО?"):**
  - `/etc/nftables.d/forward-services.nft`: **Роль "Маршрутизатор".** Включает расширенные правила для транзитного трафика (контейнеры, NAT и т.д.). **Применяется только на нужных серверах с соответствующими сервисами**
  - `/etc/nftables.d/tables-services.nft`: **Роль "Специализированный узел".** Опциональный файл предназначен для добавления очень специфических правил в цепочку input, которые требуются для работы определённых сервисов, часто связанных с кластеризацией или работой на L3/L4-уровнях.

#### Файл `definitions-infra.nft` и `definitions-services.nft`: Центр Управления Доступом

Эти два файла — сердце и мозг всей нашей конфигурации. Их можно представить как "базу данных" или "панель управления", разделенную на две части: общую (инфраструктура) и специфичную (сервисы). 
#### Основная философия: "Данные отдельно от логики"

- **Логика** (файлы `tables.nft`, `mangle.nft` и т.д.): Описывает _как_ пакеты проходят через систему (например, "сначала проверь `established`, потом `DPI`, потом основную политику..."). Эта логика сложна, отлажена и **не меняется** администраторами серверов.
- **Данные**, разделение ответственности:

  - файл `definitions-infra.nft`: Описывает _ЧТО_ конкретно разрешено или запрещено для работы в инфраструктуре. Содержит все общие для инфраструктуры объекты. Этот файл **не меняется** администраторами серверов.
  - файл `definitions-services.nft`: Описывает _ЧТО_ конкретно разрешено или запрещено для предоставляемых сервисов (например, "IP-адрес `10.10.10.5` может подключаться к порту `5432` по `TCP`"). Содержит уникальные для каждого сервера/ВМ правила. Этот файл **меняются постоянно** в ходе обычной эксплуатации администраторами серверов/ВМ.

Разделение этих двух сущностей позволяет нам изменять политики доступа, не затрагивая сложную и отлаженную логику файрвола, что делает систему стабильной и легкой в сопровождении.

#### Структура файлов

Файлы содержат определения двух типов объектов (подробное описание о сетах и мапах см. ниже):

**Структура `definitions-infra.nft`:**
Содержит все **общие** для инфраструктуры объекты:

- Сеты для динамических блокировок (`blackhole_*`).
- Сеты для временного доступа (`tmp_*_policy`).
- Сеты-исключения для организаций (`dpi_scanners`).
- Мапа **общих исходящих** правил (`output_policy_map`), например, доступ к DNS, NTP, репозиториям.

**Структура `definitions-services.nft`:**
Содержит **уникальные** для каждого сервера/ВМ правила:

- Мапа **входящего** доступа к сервисам этого сервера (`input_policy_map`).
- (Опционально) Сет для исключения защиты флуда (`trusted_nats`).
- (Опционально) Сет для защиты интерфейсов от DDOS-атак (`protected_interfaces`).
- (Опционально) Сет для защиты от спуфинга приватных сетей (`spoofed_privates_subnets`).
- (Опционально) Дополнения к `output_policy_map`, если этому серверу нужен уникальный исходящий доступ, например: исходящий (инициирующий) трафик от веб-сервера к серверу СУБД.

#### Рабочий процесс для администратора

**Если вам нужно:**

- **Открыть постоянный доступ к сервису и/или от сервиса:**

  1.  Откройте `/etc/nftables.d/definitions-services.nft`.
  2.  Найдите нужную карту (`input_policy_map` для входящего, `output_policy_map` для исходящего).
  3.  Добавьте новую строку в секцию `elements`, указав IP, протокол, порт и вердикт `accept`.

- **Дать временный доступ разработчику:**

  1.  Не редактируйте файлы.
  2.  Используйте команду `nft add element ...`, чтобы добавить запись в соответствующий `tmp_*_policy` сет с указанием таймаута.

- **Заблокировать атакующий IP:**
  1.  Не редактируйте файлы.
  2.  Используйте команду `nft add element ...`, чтобы добавить IP в `blackhole_ips` или `blackhole_services`.

**Важно!** Этот файл — ваш главный рабочий инструмент. Понимание его структуры — это ключ к эффективному и безопасному управлению файрволом.

### Файл `tables.nft`: Каркас и Логика Файрвола

Если `definitions-*.nft` — это "база данных" нашего файрвола, то `tables.nft` — это его **"логическая схема" или "блок-схема"**. Он описывает путь, который проходит каждый сетевой пакет, и на каких "перекрестках" принимаются решения.

#### Основная философия

Этот файл отвечает на вопрос **"КАК?"**, а не "ЧТО?". Он определяет последовательность шагов, которые применяются к трафику и является универсальным фундаментом, **одинаковым для всех серверов**.

#### Структура файла

Файл разделен на три основные секции, каждая из которых создает свою **таблицу**. Таблицы обрабатываются ядром в строгом порядке: `raw` -> `mangle` -> `filter`.

1.  **`table inet raw`:**

    - **Назначение:** Предварительная обработка.
    - **Задача:** Основная задача — исключить определенный трафик из системы отслеживания соединений (`conntrack`) с помощью действия `notrack`. Это делается для оптимизации на высоконагруженных системах (например, для DNS).
    - **Когда срабатывает:** Самый первый этап в сетевом стеке L3.

2.  **`table inet mangle`:**

    - **Назначение:** Модификация и пред-фильтрация.
    - **Задача:** Здесь мы можем изменять заголовки пакетов. Однако в нашей конфигурации эта таблица используется как второй, более интеллектуальный уровень защиты, где отбрасываются пакеты с аномалиями, требующие анализа L4 (например, некорректные TCP-флаги).
    - **Когда срабатывает:** Сразу после `raw`, до основной фильтрации.

3.  **`table inet filter`:**
    - **Назначение:** **Основная фильтрация.**
    - **Задача:** Это "сердце" нашего файрвола. Здесь принимаются окончательные решения `accept` (принять) или `drop` (отбросить) на основе политик из `definitions-*.nft`. Файлы определяют четыре ключевые **базовые цепочки**:
      - `prerouting`: Обрабатывает пакеты до принятия решения о маршрутизации. У нас здесь применяются правила блокировки.
      - `input`: Обрабатывает трафик, предназначенный **самому серверу**. Здесь находится наша основная логика доступа.
      - `forward`: В базовой версии эта цепочка **максимально безопасна**: она просто блокирует (`policy drop`) весь транзитный трафик. Расширенная логика для этой цепочки вынесена в отдельный файл (`forward-services.nft`), кторый обрабатывает транзитный трафик (для Docker/Kubernetes, NAT и пр.).
      - `output`: Обрабатывает исходящий трафик, сгенерированный **самим сервером**.

**Важно:** В этом файле активно используется команда `jump`. Она работает как "вызов функции" и передает управление пакета в другую цепочку (например, в `mangle_prerouting` или `log_dropped_input`), что позволяет нам сохранять основную логику чистой и модульной.

### Файл `mangle.nft`: Интеллектуальная Защита (L4)

Этот файл можно представить как **службу безопасности, которая проверяет заголовки пакетов** на корректность и выявляет подозрительное поведение. Он работает после `netdev` и `raw`, применяя более глубокий, но и более "дорогой" с точки зрения ресурсов, анализ.

#### Основная философия

Задача `mangle` — отфильтровать трафик, который не является очевидно вредоносным (как поддельный IP), но имеет признаки аномалии или попытки сканирования. Многие правила здесь требуют доступа к **системе отслеживания соединений (`conntrack`)**, поэтому их нельзя было разместить на более раннем уровне `netdev`.

#### Что именно мы здесь делаем?

1.  **Исключения для доверенных хостов:** Первым делом мы пропускаем трафик от доверенных сканеров и NAT, чтобы не применять к ним строгие проверки.
2.  **Защита от флуда (второй уровень):** Здесь могут быть размещены правила, которые ограничивают количество **новых соединений** (`ct state new`), а не просто пакетов. `ct state new` как "первый пакет" — это ключ для `input_policy_map`. Это более точная защита от SYN-флуда.
3.  **Проверка корректности TCP:** Мы проверяем:
    - Что новые TCP-соединения начинаются с правильного SYN-пакета.
    - Что в пакетах нет бессмысленных или вредоносных комбинаций флагов (NULL, XMAS, SYN+FIN и т.д.).
4.  **Защита от уязвимостей:** Мы блокируем пакеты с аномально низким значением MSS, что защищает от известных уязвимостей ядра (например, SACK Panic).

По сути, `mangle` — это наш "санитарный кордон", который пропускает в основную зону фильтрации (`filter`) только корректно сформированный и не вызывающий подозрений трафик.

### Файл `netdev.nft`: Первый Бастион Обороны

Этот файл — наш **"передовой рубеж"**. Он содержит правила, которые применяются к пакетам в самый первый момент их поступления на сетевой интерфейс, еще до того, как они попадут в сложную систему маршрутизации и фильтрации.

#### Основная философия

Задача `netdev` — выполнять **грубую, но чрезвычайно быструю** фильтрацию. Он отвечает на простые вопросы, не требующие глубокого анализа:

- "Этот IP-адрес в нашем списке на пожизненную блокировку?" -> `drop`.
- "Этот IP-адрес поддельный (спуфинг)?" -> `drop`.
- "С этого IP-адреса не идет ли слишком много пакетов (флуд)?" -> `drop`.

Так как эти проверки происходят на самом раннем этапе (`hook ingress`), отброшенные здесь пакеты потребляют **минимальное** количество ресурсов сервера. Это критически важно для защиты от массированных DDoS-атак.

#### Что именно мы здесь делаем?

1.  **"Жесткая" блокировка:** Используем сет `netdev_blackhole` для блокировки IP-адресов или целых подсетей, которые участвуют в атаках.
2.  **Защита от спуфинга:** Блокируем пакеты с очевидно поддельными адресами (например, с `127.0.0.1`, приходящим извне).
3.  **Исключения для доверенных хостов:** Пропускаем трафик от наших сканеров и корпоративных NAT в обход защиты от флуда.
4.  **Защита от флуда (первый уровень):** Ограничиваем скорость поступления пакетов (например, TCP SYN или ICMP) от каждого источника, чтобы отразить базовые флуд-атаки.

Этот файл — наш главный инструмент для смягчения (mitigation) DDoS-атак и поддержания стабильности сервера под высокой вредоносной нагрузкой.

### Файл `forward-services.nft`: Роль "Маршрутизатор"

**Назначение:** Этот **опциональный** файл содержит расширенные правила для цепочки `forward`.

**Ключевая идея:** Этот файл "включает" на сервере роль маршрутизатора или хоста например для контейнеров. Он заменяет базовую, блокирующую цепочку `forward` из `tables.nft` на более сложную, разрешающую.

**Когда использовать:**

- На хостах с **Docker** или **Kubernetes**.
- На серверах, которые должны выполнять функции **NAT-шлюза**.
- На любых других ВМ, которым нужно пересылать трафик между интерфейсами.

**Правило для администраторов:** Этот файл разворачивается **только на те серверы, которым это действительно нужно**. На обычном веб-сервере или сервере баз данных его быть не должно.

### Файл `raw-optimizations.nft`: Оптимизация Производительности

Этот файл выполняет одну, но очень специфическую задачу — **разгрузку системы отслеживания соединений (`conntrack`)**.

### Основная философия

`conntrack` — это мощный механизм, который позволяет файрволу "помнить" о каждом TCP-соединении и UDP-потоке. Это необходимо для stateful-фильтрации (правило `ct state established`). Однако, эта "память" требует ресурсов CPU и оперативной памяти.

Для некоторых протоколов, которые генерируют огромное количество коротких, независимых транзакций (например, DNS-сервер, отвечающий на тысячи запросов в секунду), ведение записей о каждом "соединении" является избыточным.

#### Что именно мы здесь делаем?

С помощью действия **`notrack`** мы говорим ядру: "Для пакетов, идущих на эти порты (DNS, NTP и др.), не создавай запись в `conntrack`".

**Преимущества:**

- **Снижение нагрузки на CPU:** Ядро выполняет меньше работы.
- **Предотвращение переполнения таблицы `conntrack`:** На очень высоконагруженных системах таблица `conntrack` может переполниться, что приведет к отбрасыванию новых легитимных соединений. `notrack` помогает этого избежать.

**Важно:** Трафик, помеченный как `notrack`, всегда будет иметь состояние `untracked`. Это значит, что для него не сработает правило `ct state established`, и для него нужно будет создавать явные разрешающие правила в обе стороны (что не является проблемой для простых протоколов типа DNS).

Более подробно см. **"Таблица RAW - Правила notrack"**

### Файл `tables-services.nft`: Специализированный узел

**Назначение:** Этот **опциональный** файл предназначен для добавления очень специфических правил в цепочку input, которые требуются для работы определённых сервисов, часто связанных с кластеризацией или работой на L3/L4-уровнях.

**Ключевая идея:** Он наполняет пустую цепочку `custom_input_rules`, которая вызывается в `tables.nft` до основной проверки по картам доступа. Это позволяет разрешить трафик по протоколам, у которых нет "портов" в привычном понимании.

**Когда использовать:**

- На узлах кластера с Keepalived, чтобы разрешить протокол VRRP.
- На балансировщиках нагрузки, использующих IGMP для управления multicast-группами.
- На серверах, участвующих в сложных сетевых протоколах, которые требуют явного разрешения по номеру протокола (ip protocol ...).

**Правило для администраторов:** Этот файл создаётся и наполняется только на тех серверах, где это необходимо. На 95% обычных серверов приложений или баз данных он не нужен.

## Руководство по `set` и `map`

Вся наша политика безопасности построена не на сотнях отдельных правил, а на двух мощных объектах `nftables`: **сетах (`set`)** и **картах (`map`)**. Понимание их назначения и различий — это ключ к эффективному и безопасному управлению файрволом.

### Сеты (`set`) — Динамические списки и Группы

#### Что это и для чего?

**Сет** — это именованный **список (набор) элементов**. Представьте его как "список гостей", "черный список" или "список временных пропусков". Основная задача сетов в нашей конфигурации — управление **динамическими**, **временными** или **групповыми** правилами.

#### Когда мы их используем?

1.  **Временные блокировки (`blackhole_ips`, `blackhole_services`):**

    - **Задача:** Быстро забанить IP-адрес (целиком или для конкретного порта) на определенное время.
    - **Почему `set`?** Потому что он поддерживает флаг `timeout`, который **автоматически удаляет** элемент по истечении срока.

2.  **Временный доступ (`tmp_input_policy`, `tmp_output_policy`):**

    - **Задача:** Дать временный доступ для отладки или решения оперативной задачи.
    - **Почему `set`?** Опять же, `timeout` гарантирует, что временное правило не станет постоянной дырой в безопасности.

3.  **Группы-исключения (`dpi_scanners`, `trusted_nats`):**
    - **Задача:** Применить особое правило для целой группы хостов (например, "не применять защиту от флуда к этим IP").
    - **Почему `set`?** Это позволяет нам сгруппировать несколько IP в один именованный объект и использовать его в одном правиле, что делает конфигурацию чище.

#### Ключевые возможности: Временные правила и Интервалы

Сеты обладают двумя мощными флагами:

- **`flags timeout`:** Позволяет элементам **автоматически удаляться** по истечении заданного времени. Это наш главный инструмент для временных правил.
- **`flags interval`:** Позволяет сету хранить **диапазоны** как один элемент. Это относится и к IP-адресам, и к портам:
  - **IP-адреса:** Вместо добавления сотен отдельных IP, мы можем добавить целую **подсеть** (например, `10.20.30.0/24`).
  - **Порты:** Вместо добавления множества портов по одному, мы можем добавить **диапазон** (например, `30000-31000` для пассивных портов FTP).

#### Как использовать?

Управление сетами происходит **"на лету" через командную строку**, без перезагрузки сервиса `nftables`. Изменения, сделанные таким образом, **не сохраняются** после перезагрузки, что идеально для временных задач.

- **Просмотр содержимого:** `sudo nft list set inet filter blackhole_ips`
- **Добавление элемента:**
  - _Простой (IP):_ `sudo nft add element inet filter blackhole_ips { 1.2.3.4 }`
  - _Сложный (IP, протокол, порт) с таймаутом:_ `sudo nft add element inet filter tmp_input_policy { 1.2.3.4 . tcp . 8080 timeout 1h }`
  - _С диапазоном портов:_ `sudo nft add element inet filter tmp_input_policy { 1.2.3.4 . udp . 30000-31000 }`
- **Удаление элемента:** `sudo nft delete element inet filter blackhole_ips { 1.2.3.4 }`

### Карты (`map`) — Статические политики доступа (ACL)

#### Что это и для чего?

**Карта** — это более сложная и мощная структура, работающая по принципу **"ключ -> значение"**. Представьте ее как "план рассадки на банкете": каждому гостю (ключу) назначено конкретное место (значение). В нашей конфигурации карты — это основной инструмент для реализации **постоянных политик доступа (Access Control Lists)**.

#### Когда мы их используем?

1.  **Основная политика входящего доступа (`input_policy_map`):** Эта карта содержит все **постоянные** правила, описывающие, кто и к каким сервисам на этом сервере может подключаться.
2.  **Основная политика исходящего доступа (`output_policy_map`):** Эта карта описывает все **постоянные разрешенные** исходящие соединения, которые может устанавливать сам сервер.

#### Ключевые особенности

- **Производительность:** `map` реализован как хэш-таблица, что обеспечивает чрезвычайно быстрый поиск. Это идеальный выбор для правил, которые проверяются для каждого пакета.
- **Статичность:** Карты **не поддерживают** флаг `timeout`. Они предназначены для хранения постоянных, а не временных, правил.

#### Как использовать?

Карты содержат **статическую** политику, которая является частью "законодательства" нашего файрвола. Поэтому управление ими происходит через формальную процедуру редактирования файла конфигурации.

1.  **Откройте** файл `/etc/nftables.d/definitions-services.nft`.
2.  **Найдите** нужную карту (`input_policy_map` или `output_policy_map`).
3.  **Добавьте новую строку** в секцию `elements`. Например, чтобы разрешить новой смежной задаче доступ к API Вашего веб-сервиса:
    ```diff
      elements = {
          # ... существующие правила ...
          10.10.10.0/24 . tcp . 22 : accept,
    +     # Новый сервер смежной задачи
    +     10.10.20.55 . tcp . 433 : accept,
      }
    ```
4.  **Проверьте синтаксис** перед применением: `sudo nft --check -f /etc/nftables.conf`.
5.  **Примените конфигурацию**: `sudo systemctl reload nftables.service`.

**Важно:** Технически `nftables` позволяет менять карты из командной строки. Мы **не используем** этот подход, чтобы избежать рассинхронизации между текущими правилами и файлами конфигурации. Все постоянные изменения должны быть задокументированы в `definitions-services.nft`.

---

### Рекомендации и итог: Когда что выбрать?

| Критерий             | Используйте Сет (`set`)                         | Используйте Карту (`map`)                               |
| :------------------- | :---------------------------------------------- | :------------------------------------------------------ |
| **Задача**           | Сгруппировать элементы для одного правила       | Создать детальную политику "если `ключ`, то `значение`" |
| **Тип правил**       | **Временные**, динамические, исключения         | **Постоянные**, статические, основные ACL               |
| **Управление**       | **Командная строка** (`nft add/delete`)         | **Редактирование файла** `definitions-services.nft`     |
| **Постоянство**      | Изменения **не сохраняются** после перезагрузки | Изменения **сохраняются**                               |
| **Нужен `timeout`?** | **Да**, это их основное преимущество            | Нет, не поддерживается                                  |
| **Нужны диапазоны?** | **Да**, с флагом `flags interval`               | Нет, ключ должен быть дискретным                        |

Это три блестящих, абсолютно необходимых дополнения! Вы смотрите на документацию глазами администратора, который будет внедрять это в реальной жизни, и предвосхищаете все его "болевые точки".

**Что думаю? Я думаю, это именно те разделы, которые превратят отличную документацию в бесценное практическое руководство.**

## Таблица RAW - Правила notrack

**Правила notrack** — это специфическая оптимизация, которая нужна только для высоконагруженных серверов, предоставляющих определенные услуги (DNS, DHCP, NTP и т.д.).

Для обычного веб-сервера или сервера баз данных, который является только клиентом этих сервисов, эта оптимизация не нужна (генерируется ничтожно мало такого трафика), потенциально вредна (отключение conntrack лишает вас возможности видеть эти "соединения" в утилитах вроде conntop, что может усложнить отладку).

### `notrack` нужен на серверах или на клиентах?

**`notrack` имеет смысл применять только на СЕРВЕРАХ, которые обслуживают огромное количество запросов.**

- **Что делает `notrack`?** Он говорит ядру: "Не создавай запись в таблице `conntrack` для этого пакета".
- **Когда `conntrack` создает нагрузку?** Когда в эту таблицу постоянно добавляются и удаляются тысячи записей в секунду.

**Сценарий 1: Ваш DNS-сервер**

- Он получает 10 000 DNS-запросов (UDP) в секунду от разных клиентов.
- **Без `notrack`:** Ядро должно создать 10 000 записей в `conntrack`, а через несколько секунд их удалить. Это создает значительную нагрузку.
- **С `notrack`:** Ядро просто пропускает эти пакеты, не тратя ресурсы на их "запоминание". **Выигрыш в производительности огромен.**

**Сценарий 2: Ваш веб-сервер (клиент DNS)**

- Он раз в 5 минут отправляет один DNS-запрос, чтобы узнать IP-адрес API.
- **Без `notrack`:** Ядро создает одну запись в `conntrack` и через несколько секунд ее удаляет. Нагрузка — **ноль**.
- **С `notrack`:** Вы экономите одну операцию записи-удаления в `conntrack`. Выигрыш в производительности — **ноль**.

**Вывод:**
Правила `notrack` предназначены для **серверной стороны** высокочастотных, "безсессионных" протоколов. Для **клиентской стороны**, которая генерирует единичные запросы, они не приносят никакой пользы.

Отличная идея! Дополнить таблицу этими протоколами — это именно то, что нужно, чтобы сделать памятку исчерпывающей. Администраторы часто сталкиваются с ними и должны четко понимать, как с ними работать.

Вот обновленная таблица-памятка и детальное объяснение по каждому из протоколов, которое можно добавить в вашу Wiki.

### Таблица с рекомендациями

| Протокол               | Роль хоста                                      | Рекомендация по `notrack` | Почему?                                                                                                                                  |
| :--------------------- | :---------------------------------------------- | :------------------------ | :--------------------------------------------------------------------------------------------------------------------------------------- |
| **DNS (domain)**       | **Сервер** (отвечает на >1000 запросов/сек)     | **Рекомендуется**         | Тысячи коротких UDP-транзакций. `conntrack` создает избыточную нагрузку.                                                                 |
|                        | **Клиент** (отправляет запросы)                 | **Не нужно**              | Нагрузка от единичных запросов нулевая.                                                                                                  |
| **NTP**                | **Сервер** (обслуживает много клиентов)         | **Рекомендуется**         | Аналогично DNS: много коротких UDP-транзакций.                                                                                           |
|                        | **Клиент** (синхронизирует время)               | **Не нужно**              | Нагрузка от периодических запросов нулевая.                                                                                              |
| **DHCP (bootps)**      | **Сервер** (раздает IP-адреса)                  | **Рекомендуется**         | Обслуживает широковещательные (broadcast) запросы. `conntrack` может плохо с ними работать и создает лишнюю нагрузку.                    |
|                        | **Клиент** (получает IP-адрес)                  | **Не нужно**              | Запрос происходит только при старте системы/интерфейса. Нагрузки нет.                                                                    |
| **TFTP**               | **Сервер** (например, для сетевой загрузки PXE) | **Рекомендуется**         | Очень простой UDP-протокол. Отключение `conntrack` немного упрощает правила и снижает нагрузку при одновременной загрузке многих хостов. |
|                        | **Клиент** (загружает/скачивает файлы)          | **Не нужно**              | Нагрузки нет.                                                                                                                            |
| **FTP**                | Сервер или Клиент                               | **Категорически НЕЛЬЗЯ**  | **Ломает работу `conntrack`-помощника**, который необходим для динамического открытия портов для данных.                                 |
| **NFS**                | Сервер или Клиент                               | **Не рекомендуется**      | Современный NFS работает по TCP. Выигрыш в производительности нулевой, но есть риски усложнения и нестабильности.                        |
| **HTTP(S), SSH, СУБД** | Сервер или Клиент                               | **Не нужно**              | Это классические долгоживущие TCP-соединения. `conntrack` идеально для них подходит и не создает лишней нагрузки.                        |

#### DNS (domain, порт 53 UDP и TCP)

- **Что это:** Система доменных имен. Преобразует имена сайтов (например, `google.com`) в IP-адреса (`172.217.16.14`). Использует UDP для быстрых запросов и TCP для больших ответов или передачи зон.
- **Рекомендация для DNS-сервера:** **Рекомендуется** использовать `notrack`. Публичный или корпоративный DNS-сервер обрабатывает тысячи очень коротких UDP-транзакций в секунду. Отслеживание каждой из них в `conntrack` создает значительную и ненужную нагрузку на CPU.
- **Рекомендация для DNS-клиента (ваш сервер):** **Не нужно**. Ваш сервер отправляет лишь несколько DNS-запросов по мере необходимости. Нагрузка на `conntrack` от этих единичных событий абсолютно нулевая.

#### NTP (Network Time Protocol, порт 123 UDP)

- **Что это:** Протокол для синхронизации времени на компьютерах и устройствах. Критически важен для корректной работы логов, TLS-сертификатов, аутентификации Kerberos и т.д.
- **Рекомендация для NTP-сервера:** **Рекомендуется** использовать `notrack`. Аналогично DNS, NTP-сервер обслуживает большое количество клиентов с помощью коротких UDP-транзакций. Отключение `conntrack` снижает нагрузку.
- **Рекомендация для NTP-клиента (ваш сервер):** **Не нужно**. Сервер-клиент отправляет запросы на синхронизацию всего несколько раз в час. Нагрузка на `conntrack` от этого пренебрежимо мала.

#### DHCP (bootps, порты 67/68 UDP)

- **Что это:** Протокол динамической конфигурации хоста. Используется для автоматического получения IP-адреса, маски, шлюза и DNS-серверов.
- **Рекомендация для DHCP-сервера:** **Рекомендуется** использовать `notrack`. DHCP-сервер работает с широковещательными запросами на раннем этапе загрузки клиентов, и `conntrack` может некорректно их обрабатывать или создавать ненужную нагрузку. Отключение отслеживания для DHCP-сервера является стандартной практикой.
- **Рекомендация для DHCP-клиента (ваш сервер):** **Не нужно**. Ваш сервер отправляет DHCP-запрос только один раз при старте сетевого интерфейса. Нагрузка на `conntrack` от этого события абсолютно нулевая.

#### TFTP (Trivial File Transfer Protocol, порт 69 UDP)

- **Что это:** Очень простой протокол для передачи файлов по UDP. Часто используется для сетевой загрузки операционных систем (PXE boot), обновления прошивок сетевых устройств и т.д.
- **Рекомендация для TFTP-сервера:** **Рекомендуется** использовать `notrack`. TFTP — это простой протокол без установления сессии. Если ваш сервер обслуживает одновременную загрузку десятков или сотен устройств, отключение `conntrack` снизит нагрузку и упростит правила (так как не нужно беспокоиться о `RELATED` пакетах на динамических портах, которые использует TFTP для передачи данных).
- **Рекомендация для TFTP-клиента:** **Не нужно**. Как и в других случаях, если ваш сервер выступает клиентом и скачивает один файл, выигрыша в производительности не будет.

#### FTP (File Transfer Protocol, порт 21 TCP)

- **Что это:** Старый протокол для передачи файлов. Использует одно соединение для команд (порт 21) и отдельные, динамические соединения для передачи данных.
- **Рекомендация для сервера или клиента:** **Категорически НЕЛЬЗЯ** использовать `notrack`. `conntrack` имеет специального "помощника" (`helper`) для FTP, который "подслушивает" управляющее соединение на порту 21, чтобы узнать, какой динамический порт нужно открыть для передачи данных. Если вы включите `notrack` для порта 21, "помощник" будет ослеплен, и передача файлов будет **заблокирована** файрволом.

#### NFS (Network File System, порт 2049 TCP/UDP)

- **Что это:** Протокол для предоставления "сетевого" доступа к файловым системам, позволяя монтировать удаленные директории как локальные.
- **Рекомендация для сервера или клиента:** **Не рекомендуется**. Современные версии NFS (v4 и выше) преимущественно используют TCP, который является протоколом с установлением соединения. `conntrack` идеально подходит для его отслеживания. Даже при интенсивной передаче файлов количество _новых соединений_ невелико, а значит, нагрузка на `conntrack` минимальна. Отключение `notrack` не дает выигрыша в производительности, но может усложнить диагностику и нарушить работу более сложных сценариев NFS.

#### HTTP(S), SSH, СУБД (PostgreSQL, MySQL и др.)

- **Что это:** Это класс долгоживущих, сессионных протоколов, работающих поверх TCP. Они являются основой практически всех современных приложений.
- **Рекомендация для сервера или клиента:** **Не нужно** и **бессмысленно**. Эти протоколы — именно то, для чего была создана система `conntrack`. Она идеально отслеживает жизненный цикл TCP-соединений (установка, передача данных, закрытие). Отключение `conntrack` для них полностью ломает концепцию stateful-файрвола и потребовало бы создания сложных и ненадежных правил для разрешения обратного трафика вручную.

### Вывод

`notrack` — это инструмент **оптимизации**, а не безопасности. Он отключает систему отслеживания соединений (`conntrack`) для определенного трафика.

#### Правило №1: По умолчанию — НЕ ИСПОЛЬЗУЙТЕ `notrack`

Система `conntrack` — это основа нашего stateful-файрвола. Отключайте ее только при наличии веских причин.

#### Правило №2: Когда СТОИТ рассмотреть `notrack`?

Только при совпадении **ВСЕХ ТРЕХ** условий:

- **A) Условие нагрузки:** Речь идет о **тысячах очень коротких транзакций в секунду**.
- **Б) Условие роли:** `notrack` применяется на **СЕРВЕРНОЙ** стороне, которая принимает огромное количество запросов.
- **В) Условие протокола:** Протокол должен быть простым (обычно UDP, "запрос-ответ").

**Важно:** Использование `notrack` означает, что вы больше не можете полагаться на `ct state related,established` для этого трафика. Вам может потребоваться создать более детальные разрешающие правила, если протокол использует несколько портов. Для простых протоколов, перечисленных в таблице, это обычно не является проблемой.

## Внедрение и Отладка

### 1. Как применять и активировать конфигурацию `nftables`

После того как все файлы созданы в директории `/etc/nftables.d/` и главный файл `/etc/nftables.conf` настроен, процесс активации состоит из двух шагов: подготовка и включение сервиса.

#### Шаг 1: Подготовка и ручная активация

**КРИТИЧЕСКИ ВАЖНО:** Перед первой активацией всегда проверяйте синтаксис. Это убережет Вас от ошибок, которые могут заблокировать Вам доступ к серверу (особенно по SSH).

1.  **Проверка синтаксиса:**

    ```bash
    sudo nft --check -f /etc/nftables.conf
    ```

    Если команда ничего не вывела — ошибок нет.

2.  **Ручная активация:**

    ```bash
    sudo nft -f /etc/nftables.conf
    ```

    После этой команды правила немедленно станут активны. **Не закрывайте текущую SSH-сессию!** Откройте новую и убедитесь, что доступ к серверу сохранился.

3.  **Проверка загруженных правил:**
    ```bash
    sudo nft list ruleset
    ```
    Вы должны увидеть полную конфигурацию, собранную из всех ваших файлов.

#### Шаг 2: Включение автозагрузки

Чтобы правила автоматически применялись после каждой перезагрузки, нужно включить сервис `nftables`.

```bash
# Включаем сервис (добавляем в автозагрузку) и сразу же запускаем его
sudo systemctl enable --now nftables.service
```

После этого проверьте его статус:

```bash
sudo systemctl status nftables.service
```

Вы должны увидеть `Active: active (exited)`. Это нормальное поведение: сервис запускается, загружает правила и завершается.

### 2. Сосуществование с `iptables` и контейнерами

Это очень важный момент.

#### Нужно ли обнулять `iptables`?

**Зависит от режима работы `iptables`.**

1.  **Проверьте режим:**
    ```bash
    sudo iptables --version
    ```
2.  **Если вывод `(nf_tables)` (современный режим):**

    - **Ничего обнулять НЕ НУЖНО!** `iptables` и `nft` работают с одной и той же подсистемой ядра. Команда `flush ruleset` в вашем `/etc/nftables.conf` уже очищает **все** правила, включая те, что могли быть созданы через `iptables`.

3.  **Если вывод `(legacy)` (старый режим):**

    - **Если на сервере НЕТ Docker/Kubernetes:** перед активацией `nftables` настоятельно рекомендуется полностью очистить старые правила `iptables`, чтобы избежать конфликтов.
      ```bash
      # Очистка всех правил, цепочек и таблиц iptables-legacy
      sudo iptables -F
      sudo iptables -X
      sudo iptables -t nat -F
      sudo iptables -t nat -X
      sudo iptables -t mangle -F
      sudo iptables -t mangle -X
      sudo iptables -P INPUT ACCEPT
      sudo iptables -P FORWARD ACCEPT
      sudo iptables -P OUTPUT ACCEPT
      # И отключить сервис iptables, если он был
      sudo systemctl disable iptables.service
      ```
    - **Если на сервере ЕСТЬ Docker/Kubernetes:** **НИ В КОЕМ СЛУЧАЕ НЕ ОБНУЛЯЙТЕ ПРАВИЛА `iptables` ВРУЧНУЮ!** Docker и K8s критически зависят от своих правил `iptables` для работы сети. В этом случае **категорически рекомендуется** сначала переключить систему в режим `iptables-nft`, чтобы все работали с одной подсистемой.

      ```bash
      # Для Debian/Ubuntu
      sudo update-alternatives --config iptables
      # (и выбрать /usr/sbin/iptables-nft)

      # Для RHEL/CentOS
      sudo alternatives --set iptables /usr/sbin/iptables-nft
      ```

      После переключения и перезапуска Docker/Kubernetes (лучше перезагрузить сервер) их правила будут созданы уже в `nftables` и будут корректно сосуществовать с Вашими.

### 3. Режим "Аудита": Как проверить правила перед блокировкой

Перед тем как "включать рубильник" и переводить файрвол в блокирующий режим (`policy drop`), крайне полезно запустить его в режиме "пассивного аудита". Это позволит Вам убедиться, что Вы не забыли никакие важные правила, не нарушив при этом работу сервисов.

**Цель:** Временно разрешить весь трафик, но **логировать** все пакеты, которые **были бы заблокированы** в боевом режиме.

#### Шаг 1: Временно меняем политики на `ACCEPT`

Вам нужно временно отредактировать **только один файл** — `/etc/nftables.d/tables.nft`.

```diff
# Файл: /etc/nftables.d/tables.nft (ВРЕМЕННАЯ ВЕРСИЯ ДЛЯ АУДИТА)

    # Цепочка для входящего трафика
    chain input {
-       type filter hook input priority 0; policy drop;
+       type filter hook input priority 0; policy accept;
        ...
    }

    # Цепочка для транзитного трафика
    chain forward {
-       type filter hook forward priority 0; policy drop;
+       type filter hook forward priority 0; policy accept;
        ...
    }

    # Цепочка для исходящего трафика
    chain output {
-       type filter hook output priority 0; policy drop;
+       type filter hook output priority 0; policy accept;
        ...
    }
```

#### Шаг 2: Включаем логирование "по умолчанию"

Теперь нужно "поймать" и залогировать пакеты, которые не подошли ни под одно из разрешающих правил. Для этого нужно использовать "цепочки-переключатели" логов.

**Включите логирование для всех заблокированных пакетов одной командой:**

```bash
# Для входящего трафика
sudo nft add rule inet filter log_dropped_input counter log prefix "[AUDIT-INPUT:WILL_BE_DROP] " level warn

# Для исходящего трафика
sudo nft add rule inet filter log_dropped_output counter log prefix "[AUDIT-OUTPUT:WILL_BE_DROP] " level warn

# Для транзитного трафика
sudo nft add rule inet filter log_dropped_forward counter log prefix "[AUDIT-FORWARD:WILL_BE_DROP] " level warn
```

#### Шаг 3: Анализ и возврат в боевой режим

1.  **Дайте системе поработать** в таком режиме несколько часов или день, в зависимости от интенсивности трафика.
2.  **Анализируйте логи:**
    ```bash
    sudo journalctl -k | grep "WILL_BE_DROP"
    ```
    Ищите в логах легитимный трафик, который забыли разрешить. Например, можете увидеть, что веб-сервер пытается обратиться к новому API (`[AUDIT-OUTPUT:WILL_BE_DROP]...`), и поймете, что нужно добавить это правило в `output_policy_map`.
3.  **Вернитесь в боевой режим:**
    - **Очистите** цепочки логирования: `sudo nft flush chain inet filter log_dropped_input` (и для других).
    - **Верните `policy drop`** во все цепочки в файле `tables.nft`.
    - **Перезагрузите сервис `nftables`**, чтобы применить финальную, блокирующую конфигурацию.

Этот процесс позволяет провести внедрение файрвола максимально гладко и безопасно, минимизируя риски нарушения работы сервисов.

## Конфигурационные файлы

```bash
# Создать бекап конфигурационного файла
cp /etc/nftables.conf{,.$(date +"%Y-%m-%d_%H-%M-%S")}

# Создать директорию для конфигурационных файлов
mkdir -p /etc/nftables.d

# Файл, который применится при загрузке nftable
cat <<EOF >/etc/nftables.conf
# Ссылка на официальную документацию Red Hat, полезно для глубокого изучения.
# More documentations: https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/getting-started-with-nftables_configuring-and-managing_networking

# Полностью очищает все существующие правила в ядре перед загрузкой новых.
# Гарантирует, что применяются только правила из этих файлов, предотвращает дублирование и конфликты.
# Это обязательная первая команда в любом главном файле.
flush ruleset

# Включает файл с определениями (сеты и карты).
# Загружаем все "данные" (списки IP, портов) в первую очередь, чтобы они были доступны для правил в последующих файлах.
# Порядок включения файлов имеет значение!
# Файл с данными описывающий доступ к инфраструктуре
include "/etc/nftables.d/definitions-infra.nft"
# Файл с данными описывающий доступ к сервисам на сервере/ВМ
include "/etc/nftables.d/definitions-services.nft"

# Включает файл с основной структурой таблиц и цепочек.
include "/etc/nftables.d/tables.nft"

# Включает файл с правилами для таблицы 'netdev'.
include "/etc/nftables.d/netdev.nft"

# Включает файл с правилами для таблицы 'mangle'.
include "/etc/nftables.d/mangle.nft"

# Опционально включаем правила для контейнеров, если файл существует.
# Это более продвинутый синтаксис, при отсутствии файла не вызывает ошибки.
include optional "/etc/nftables.d/forward-services.nft"

# Опционально включаем специфические правила для tables, если файл существует.
include optional "/etc/nftables.d/tables-services.nft"

# Опционально включаем оптимизации raw, если файл существует.
include optional "/etc/nftables.d/raw-optimizations.nft"
EOF

cat <<EOF >/etc/nftables.d/definitions-infra.nft
# Назначение: Содержит ОБЩИЕ, БАЗОВЫЕ определения и политики,
# применяемые ко ВСЕМ серверам в инфраструктуре.
# Управляется централизованно командой инфраструктуры.
#
# Ключевая идея: Разделение "данных" (ЧТО разрешено/запрещено) от "логики" (КАК обрабатывается трафик).
#

# --- ПЕРЕМЕННЫЕ ДЛЯ ТЮНИНГА ЗАЩИТЫ ---
# Здесь определяются значения "по умолчанию" для лимитов защиты от флуда.
# Эти значения могут быть переопределены для специфических ролей серверов
# в файле definitions-services.nft.

# --- Лимиты для защиты от ICMP-флуда (уровень netdev) ---
define icmp4_flood_rate = 1/second
define icmp4_flood_burst = 5 packets
define icmp6_flood_rate = 5/second
define icmp6_flood_burst = 5 packets

# --- Лимиты для защиты от TCP SYN-флуда (уровень netdev) ---
define syn_flood_rate = 10/second
define syn_flood_burst = 20 packets

# --- Лимиты для защиты от флуда НОВЫМИ СОЕДИНЕНИЯМИ (более точная защита, уровень mangle) ---
define conn_flood_rate = 15/second
define conn_flood_burst = 30 packets

table inet filter {

    # Сет для ПОЛНОЙ временной блокировки IP-адресов
    set blackhole_ips {
        # Поддерживаемы типа IPv4 и IPv6
        type { ipv4_addr, ipv6_addr }
        # Флаги: таймаут и поддержка диапазонов портов и подсетей.
        flags timeout, interval
        timeout 1d        # По-умолчанию 24 часа
        # Как использовать:
        # Блокирует ВЕСЬ трафик от 1.2.3.4 на 24 часа.
        # ip4
        # sudo nft add element inet filter blackhole_ips { 1.2.3.4 }
        # ip6
        # sudo nft add element inet filter blackhole_ips { "2001:db8::dead:beef" }
        # Блокируем всю подсеть 10.200.*.*
        # sudo nft add element inet filter blackhole_ips { 10.200.0.0/16 }
    }

    # --- Сет для ТОЧЕЧНОЙ временной блокировки доступа к сервисам ---
    set blackhole_services {
        type { ipv4_addr, ipv6_addr } . l4proto . inet_service
        # Флаги: таймаут и поддержка диапазонов портов и подсетей.
        flags timeout, interval
        timeout 1h        # По-умолчанию 1 час
        # Как использовать:
        # Блокирует трафик от 1.2.3.4 только на TCP-порт 80 на 1 час.
        # sudo nft add element inet filter blackhole_services { 1.2.3.4 . tcp . 80 }
        # sudo nft add element inet filter blackhole_services { 2001:db8::1 . tcp . 80 timeout 10h }
    }

    # Сет для доверенных NAT-адресов, исключенных из-под защиты от флуда
    # Здесь сет объявляется пустым для корректной работы правил.
    # Наполняется при необходимости в файле definitions-services.nft для конкретного сервера.
    set trusted_nats {
        type { ipv4_addr, ipv6_addr }
        # Флаги: поддержка диапазонов подсетей.
        flags interval
        elements = {}
    }

    # Сет для приватных подсетей защиты от спуфинга
    # Здесь сет объявляется пустым для корректной работы правил.
    # Наполняется при необходимости в файле definitions-services.nft для конкретного сервера.
    set spoofed_privates_subnets {
        # Тип данных: хранит IPv4 и IPv6 адреса.
        type { ipv4_addr, ipv6_addr }
        # Флаги: поддержка диапазонов подсетей.
        flags interval
        elements = {}
    }

    # Сет для доверенных DPI-сканеров, которым разрешен полный доступ
    set dpi_scanners {
        # Тип данных: хранит IPv4 и IPv6 адреса.
        type { ipv4_addr, ipv6_addr }
        # Флаги: поддержка диапазонов портов и подсетей.
        flags interval
        # Элементы: IP-адреса ваших сканеров уязвимостей.
        elements = {
            10.10.100.5, # Например, сервер Qualys
            10.10.100.6,  # Например, сервер Nessus
            # fe80::1234:5678:9abc:def0, # Пример IPv6-адреса сканера
        }
    }

    # Сет для предоставления ВРЕМЕННОГО и ТОЧЕЧНОГО доступа
    set tmp_input_policy {
        # Тип данных: хранит тройку "IP-адрес . Протокол . Порт".
        type { ipv4_addr, ipv6_addr } . l4proto . inet_service

        # Флаги: таймаут и поддержка диапазонов портов и подсетей.
        flags timeout, interval
        timeout 1d

        # Как использовать (НОВЫЙ СИНТАКСИС):
        # --- TCP ---
        # sudo nft add element inet filter tmp_input_policy { 1.2.3.4 . tcp . 8080 timeout 1h }
        # --- UDP ---
        # sudo nft add element inet filter tmp_input_policy { 1.2.3.4 . udp . 51820 timeout 4h }
        # sudo nft add element inet filter tmp_input_policy { 1.2.3.4 . udp . 30000-35000 timeout 2d }
    }

    # Сет для ВРЕМЕННОГО и ТОЧЕЧНОГО ИСХОДЯЩЕГО доступа
    set tmp_output_policy {
        # Тип данных: тройка "IP-адрес НАЗНАЧЕНИЯ . Протокол . Порт"
        type { ipv4_addr, ipv6_addr } . l4proto . inet_service

        # Флаги: таймаут и поддержка диапазонов портов и подсетей.
        flags timeout, interval
        timeout 1h # <-- Для временного исходящего доступа 1 час - хороший таймаут по умолчанию

        # Как использовать:
        # Разрешить серверу обратиться к 1.1.1.1 по TCP на порт 443 на 1 час.
        # sudo nft add element inet filter tmp_output_policy { 1.1.1.1 . tcp . 443 }
    }

    # Мапа доступа для всех сервисов на сервере/ВМ (TCP и UDP)
    map input_policy_map {
        # Тип ключа: тройка "IP-адрес . Протокол L4 . Порт"
        # Тип значения: вердикт (accept)
        type { ipv4_addr, ipv6_addr } . l4proto . inet_service : verdict

        elements = {
            # --- ИНФРАСТРУКТУРНЫЕ СЕРВИСЫ (которые инициализируют соединения к своим агентам на Вашем сервере) ---
            # Netbackup (TCP)
            10.10.20.21 . tcp . 13782 : accept,
            # Zabbix (TCP)
            10.10.20.10 . tcp . 10050 : accept,
            # VictoriaMetrics - vmagent (TCP)
            10.10.20.20 . tcp . 8429  : accept,

            # Kesl-agent (TCP)
            10.10.40.14 . tcp . 13000 : accept,

            # --- ПРИМЕР: DNS-сервер (UDP и TCP) ---
            # Для сервера, который предоставляет DNS-сервис (обычные сервера не предоставляют DNS):
            # 10.0.0.0/8 . udp . 53 : accept,
            # 10.0.0.0/8 . tcp . 53 : accept,

            # --- ПРИМЕР: NTP-сервер (UDP) ---
            # Для сервера, который держит NTP-сервис (обычные сервера не предоставляют NTP):
            # 0.0.0.0/0 . udp . 123 : accept, # NTP часто доступен отовсюду
        }
    }

    # Мапа для разрешенного исходящего трафика
    map output_policy_map {
        # Тип ключа: тройка "IP-адрес НАЗНАЧЕНИЯ . Протокол L4 . Порт НАЗНАЧЕНИЯ"
        type { ipv4_addr, ipv6_addr } . l4proto . inet_service : verdict

        elements = {
            # --- БАЗОВЫЕ ИНФРАСТРУКТУРНЫЕ СЕРВИСЫ ---
            # 1. DNS: Разрешаем серверу обращаться к DNS-серверам.
            10.10.10.1 . udp . 53 : accept,
            10.10.10.1 . tcp . 53 : accept,
            # Для ДМЗ: разрешаем ДНС запросы только на яндекс-серверам.
            # 77.88.8.8 . udp . 53 : accept,
            # 77.88.8.1 . tcp . 53 : accept,

            # 2. NTP: Разрешаем синхронизацию времени.
            10.10.10.2 . udp . 123 : accept,
            192.168.1.1 . udp . 123 : accept,

            # 3. Zabbix Agent (Active Checks): Разрешаем агенту отправлять данные на Zabbix-сервер.
            # Zabbix Agent (active) -> Zabbix Server
            10.10.20.10 . tcp . 10051 : accept,

            # --- ОБНОВЛЕНИЯ И ПАКЕТЫ ---
            # 4. Репозитории пакетов (HTTP/HTTPS).
            # Это САМАЯ ВАЖНАЯ часть для поддержания системы в рабочем состоянии.
            # Пример для корпоративного зеркала:
            10.10.50.100 . tcp . http : accept,
            10.10.50.100 . tcp . https : accept,
        }
    }
}
EOF

cat <<EOF >/etc/nftables.d/definitions-services.nft
# Назначение: Содержит определения и политики, СПЕЦИФИЧНЫЕ для
# сервисов, работающих на ДАННОМ сервере.
# Управляется администратором конкретного сервера/сервиса.

# Этот блок содержит специфичные для текущего сервера/ВМ настройки, которые используются в файле netdev.nft

# --- ПЕРЕМЕННЫЕ ДЛЯ ТЮНИНГА ЗАЩИТЫ ---
# Здесь при необходимости переопределяются значения "по умолчанию" для лимитов защиты от флуда из файла definitions-infra.nft
# --- Лимиты для защиты от ICMP-флуда (уровень netdev) ---
#define icmp4_flood_rate = 5/second
#define icmp4_flood_burst = 5 packets
#define icmp6_flood_rate = 10/second
#define icmp6_flood_burst = 5 packets
# --- Лимиты для защиты от TCP SYN-флуда (уровень netdev) ---
#define syn_flood_rate = 100/second
#define syn_flood_burst = 200 packets
# --- Лимиты для защиты от флуда НОВЫМИ СОЕДИНЕНИЯМИ (более точная защита, уровень mangle) ---
#define conn_flood_rate = 15/second
#define conn_flood_burst = 30 packets

table netdev ddos {
    # Сет содержащий имена ВНЕШНИХ сетевых интерфейсов, которые должны быть защищены от DDoS-атак.
    # Если сет пустой, проверки на DDoS-атаки производиться не будут.
    set protected_interfaces {
        # Специальный тип для хранения имен интерфейсов
        type ifname

        # Пример заполнения:
        # Администратор должен раскомментировать и указать здесь
        # имя своего внешнего интерфейса (или интерфейсов).
        # elements = { "enp3s0" }

        # Пример для сервера с двумя внешними интерфейсами:
        # elements = { "enp3s0", "eth0", "ens192" }
    }
}

table inet filter {
    # Сет для доверенных NAT-адресов, исключенных из-под защиты от флуда
    # Исключаем только на тех серверах, которые предоставляют сервисы для этих подсетей. Например: доступ к веб-серверу.
    #set trusted_nats {
    #    elements = {
    #        11.0.0.0,
    #        192.168.30.25,
    #    }
    #}

    # Сет для приватных подсетей защиты от спуфинга.
    # Блокировка трафика на внешнем интерфейсе с указанных приватных подсетей.
    set spoofed_privates_subnets {
        elements = {
            169.254.0.0/16,
            172.16.0.0/12,
            192.168.0.0/16, # Закомментировать для ДМЗ
            224.0.0.0/3,
            240.0.0.0/5
            # 10.0.0.0/8    # Закомментировать для корпоративной сети
            fe80::/10,
            ff00::/8,
        }
    }

    # Мапа доступа к сервисам на текущем сервере/ВМ (TCP и UDP)
    map input_policy_map {
        # Тип ключа: тройка "IP-адрес . Протокол L4 . Порт"
        # Тип значения: вердикт (accept)
        type { ipv4_addr, ipv6_addr } . l4proto . inet_service : verdict

        elements = {
            # Доступ администраторов к серверу по SSH
            10.10.10.0/24 . tcp . ssh : accept,

            # Веб-сервер (TCP)
            10.0.0.0/8 . tcp . http : accept,
            10.0.0.0/8 . tcp . https : accept,
            # Веб-сервер (QUIC/HTTP3, UDP)
            10.0.0.0/8 . udp . 443 : accept,

            # PostgreSQL (TCP)
            10.10.10.20 . tcp . 5432 : accept,
            10.10.10.21 . tcp . 5432 : accept,
        }
    }

    # Мапа для разрешенного исходящего трафика от текущего сервера/ВМ
    map output_policy_map {
        # Тип ключа: тройка "IP-адрес НАЗНАЧЕНИЯ . Протокол L4 . Порт НАЗНАЧЕНИЯ"
        type { ipv4_addr, ipv6_addr } . l4proto . inet_service : verdict

        elements = {
            # Веб-сервер подключается к серверу СУБД
            10.10.0.90 . tcp . 5432 : accept,
            # Веб-сервер подключается к API другого веб-сервера
            10.10.1.80 . tcp . http : accept,
        }
    }
}
EOF

cat <<EOF >/etc/nftables.d/tables.nft
# Назначение: Определяет основную архитектуру и логический поток обработки пакетов.
# Этот файл создает все необходимые таблицы (`raw`, `mangle`, `filter`)
# и базовые цепочки (`prerouting`, `input`, `forward`, `output`).
#
# Ключевая идея: Этот файл является "скелетом" файрвола. Он определяет, в каком порядке
# и на каких этапах ('hook') обрабатывается трафик, и с помощью команд 'jump' делегирует
# специфические задачи другим файлам или цепочкам.
#
# Правило для администраторов: Этот файл редактируется крайне редко.
# Изменения вносятся только в случае фундаментальных изменений в архитектуре
# (например, добавление новой базовой цепочки или изменение политики по умолчанию).

# Таблица RAW: Предварительная обработка
# Используется для исключения трафика из системы отслеживания соединений (conntrack).
# Проверка передается в файл /etc/nftables.d/raw-optimizations.nft
# Более подробную информацию см. в разделе "Таблица RAW - Правила notrack"
table inet raw {
    chain prerouting {
        # filter: тип цепочки; hook prerouting: точка входа (до маршрутизации); priority -300: самый высокий приоритет.
        type filter hook prerouting priority -300; policy accept;
        # Передаем управление пользовательской цепочке, определенной в raw-optimizations.nft
        jump raw_prerouting
    }
}

# Таблица MANGLE: Модификация пакетов
# Для изменения заголовков пакетов и для ранней отбраковки вредоносных пакетов (сканирование, спуфинг).
# Проверка передается в файл /etc/nftables.d/mangle.nft
table inet mangle {
    chain prerouting {
        # priority -150: выполняется после `raw`.
        type filter hook prerouting priority -150; policy accept;
        jump mangle_prerouting
    }
}

# Таблица FILTER: Основная фильтрация
# inet: работает и для IPv4, и для IPv6.
table inet filter {
    # Пустая цепочка для расширений правил
    chain custom_input_rules {}
    # Пустые цепочки для логирования
    chain log_accepted_input {}
    chain log_dropped_input {}
    #chain log_accepted_output {}
    #chain log_dropped_output {}
    #chain log_accepted_forward {}
    #chain log_dropped_forward {}
    #chain log_accepted_netdev {}
    #chain log_dropped_netdev {}

    chain prerouting {
        type filter hook prerouting priority 0; policy accept;
    }

    # Цепочка для входящего трафика, предназначенного самому серверу.
    chain input {
        # `policy drop`: Политика по умолчанию. "Запрещено всё, что не разрешено явно".
        # Это краеугольный камень безопасности файрвола.
        type filter hook input priority 0; policy drop;

        # --- Основные разрешающие правила ---
        # Разрешает трафик для уже установленных или связанных соединений. Самое важное правило для работы stateful-файрвола.
        ct state related,established counter accept comment "Accept traffic connections"
        # Разрешает любой трафик с/на loopback-интерфейс (lo). Необходимо для работы многих локальных сервисов.
        iifname lo accept comment "Accept any localhost traffic"
        # Отбрасывает пакеты, которые не могут быть идентифицированы системой отслеживания соединений. Защита от некоторых видов атак.
        ct state invalid counter jump log_dropped_input drop comment "Drop in valid connections"

        # Проверяем, не заблокирован ли доступ к конкретному сервису.
        saddr . meta l4proto . th dport @blackhole_services counter jump log_dropped_input drop comment "Drop traffic to specific blacklisted services"

        # ПРАВИЛО-ИСКЛЮЧЕНИЕ: Если пакет пришел от доверенного DPI-сканера,
        # принимаем его, предоставляя доступ ко всем портам.
        # Это правило должно быть здесь, чтобы обойти все последующие `jump` и политику `drop`.
        saddr @dpi_scanners counter jump log_accepted_input accept comment "Allow all access for trusted DPI scanners"

        # --- Правила для ICMP (ping и служебные сообщения) ---
        # Разрешает критически важные ICMP-сообщения, необходимые для корректной диагностики сети.
        ip protocol icmp icmp type { destination-unreachable, time-exceeded, parameter-problem, echo-request } jump log_accepted_input accept comment "Accept critical ICMP types"
        ip6 nexthdr icmpv6 icmpv6 type { destination-unreachable, packet-too-big, time-exceeded, parameter-problem, nd-neighbor-solicit, nd-neighbor-advert, nd-router-solicit, nd-router-advert, echo-request } jump log_accepted_input accept comment "Accept critical ICMPv6 types"

        # --- ПЕРЕХОД К ПОЛЬЗОВАТЕЛЬСКИМ ПРАВИЛАМ ---
        # Если существует файл tables-services.nft, то дальнейшая проверка передается ему.
        # Если файла нет, эта пустая цепочка ничего не сделает.
        jump custom_input_rules

        # Включить логирование разрешенного входящего трафика. В примере логируем разрешенный входящий трафик на 22 порт.
        # sudo nft add rule inet filter log_accepted_input meta l3proto {ip, ip6} ip saddr . meta l4proto . th dport @input_policy_map tcp dport 22 counter log prefix "[INPUT-22:ACCEPTED] " level info
        # Выключить логирование (очистить цепочку):
        # sudo nft flush chain inet filter log_accepted_input

        # --- Переход к правилам для сервисов ---
        # ЕДИНОЕ ПРАВИЛО ДОСТУПА ДЛЯ ВСЕХ СЕРВИСОВ (TCP и UDP)
        # Это правило берет IP источника, протокол L4 и порт назначения из пакета
        # и ищет их комбинацию в единой карте доступа.
        # `th dport` - это "transport header destination port", работает и для TCP, и для UDP.
        saddr . meta l4proto . th dport @input_policy_map counter jump log_accepted_input accept comment "Allow services based on the unified access policy map"

        # Правило для временного доступа
        saddr . meta l4proto . th dport @tmp_input_policy counter jump log_accepted_input accept comment "Accept for temporary access policy (TCP/UDP)"

        # Включить логирование блокировки пакетов
        # sudo nft add rule inet filter log_dropped_input counter log prefix "[INPUT:BLOCKED] " level warn
        # Включить логирование блокировки пакетов на 22 порт
        # sudo nft add rule inet filter log_dropped_input tcp dport 22 counter log prefix "[INPUT-22:BLOCKED] " level warn
        #      посмотреть лог: sudo journalctl -fk | grep "INPUT-22:BLOCKED"
        # Логируем заблокированные пакеты на порт 22, но ТОЛЬКО от источника 1.2.3.4
        # sudo nft add rule inet filter log_dropped_input ip saddr 1.2.3.4 tcp dport 22 counter log prefix "[HOST-SSH-BLOCK] " level warn
        # Выключить логирование:
        # sudo nft flush chain inet filter log_dropped_input
        jump log_dropped_input
    }

    # Цепочка для транзитного трафика (сервер как роутер).
    chain forward {
        # `policy drop`: Критически важно! Запрещает серверу пересылать трафик по умолчанию.
        type filter hook forward priority 0; policy drop;

        # --- ДИНАМИЧЕСКОЕ ЛОГИРОВАНИЕ ЗАБЛОКИРОВАННОГО ТРАФИКА ---
        # Стоит в конце. Сработает для всего, что не было разрешено выше.
        # Включаем логирование заблокированного транзитного трафика
        # sudo nft add rule inet filter log_dropped_forward counter log prefix "[FORWARD:DROPPED] "
        # Пытаемся запустить `apt update` в контейнере и смотрим логи
        # sudo journalctl -fk | grep "FORWARD:DROPPED"
        jump log_dropped_forward
        # Выключить логирование:
        # sudo nft flush chain inet filter log_dropped_forward

    }

    # Цепочка для исходящего трафика (от самого сервера).
    chain output {
        # `policy accept`: Стандартная практика для серверов. Разрешает все исходящие соединения.
        #type filter hook output priority 0; policy accept;

        # 1. МЕНЯЕМ ПОЛИТИКУ НА DROP: Запрещаем все исходящие соединения по умолчанию.
        # Это критически важное изменение для реализации egress filtering.
        type filter hook output priority 0; policy drop;

        # 2. РАЗРЕШАЕМ БАЗОВЫЕ ВЕЩИ (ОБЯЗАТЕЛЬНО!)
        # Разрешаем исходящий трафик для уже установленных соединений. Без этого не будет работать ни одно TCP-соединение.
        ct state related,established counter accept comment "Allow established outgoing connections"
        # Разрешаем любой исходящий трафик на loopback-интерфейс.
        oifname lo accept comment "Allow any localhost outgoing traffic"

        # Включить логирование разрешенного исходящего трафика. В примере логируем исходящий трафик на zabbix-сервер
        # sudo nft add rule inet filter log_accepted_output meta l3proto {ip, ip6} ip daddr . meta l4proto . th dport @output_policy_map tcp dport 10051 counter log prefix "[OUTPUT-10051:ACCEPTED] " level info
        # Выключить логирование (просто очистить цепочку):
        # sudo nft flush chain inet filter log_accepted_output
        jump log_accepted_output

        # 3. ИСПОЛЬЗУЕМ КАРТУ ДЛЯ РАЗРЕШЕНИЯ ЛЕГИТИМНОГО ТРАФИКА
        # Это правило проверяет IP назначения, протокол и порт назначения пакета
        # по нашей карте разрешенных исходящих соединений.
        daddr . meta l4proto . th dport @output_policy_map counter accept comment "Allow legitimate outgoing traffic based on egress policy map"

        # 4. НОВОЕ: Правило для ВРЕМЕННОГО исходящего доступа ---
        # Проверяем, соответствует ли пакет временной политике.
        daddr . meta l4proto . th dport @tmp_output_policy counter accept comment "Allow temporary outgoing traffic"

        # Включить логирование блокировки исходящего трафика
        # sudo nft add rule inet filter log_dropped_output counter log prefix "[OUTPUT:BLOCKED] " level warn
        # Включить логирование блокированных пакетов на host 10.10.30.5
        # sudo nft add rule inet filter log_dropped_output tcp daddr 10.10.30.5 counter log prefix "[OUTPUT-10.10.30.5:BLOCKED] " level warn
        #      посмотреть лог: sudo journalctl -fk | grep "OUTPUT-10.10.30.5:BLOCKED"
        # Выключить логирование:
        # sudo nft flush chain inet filter log_dropped_output
        jump log_dropped_output
    }
}
EOF

cat <<EOF >/etc/nftables.d/mangle.nft
# Назначение: Реализует второй эшелон защиты, фокусируясь на анализе L4-заголовков
# и поведенческих аномалий, которые требуют доступа к 'conntrack'.
#
# Ключевая идея: Отбрасывать некорректно сформированные или подозрительные пакеты
# (например, с неправильными TCP-флагами, аномальным MSS) до того, как они достигнут
# основной логики фильтрации.
#
# Правило для администраторов: Редактируется редко, в основном для тюнинга параметров защиты
# от флуда или добавления новых правил для защиты от уязвимостей L4.

#table inet mangle {   # правильно ли что заменил на filter ?
table inet filter {
    chain log_accepted_mangle {}
    chain log_dropped_mangle {}

    chain mangle_prerouting {
        # Логирование разрешенных пакетов
        # Включить:
        # sudo nft add rule netdev ddos log_accepted_mangle counter log prefix "[MANGLE:ACCEPTED] "
        # Выключить:
        # sudo nft flush chain netdev ddos log_accepted_mangle
        # Логирование отброшенных пакетов
        # Включить:
        # sudo nft add rule netdev ddos log_dropped_mangle counter log prefix "[MANGLE:DROPPED] "
        # Выключить:
        # sudo nft flush chain netdev ddos log_dropped_mangle

        # ПРАВИЛО-ИСКЛЮЧЕНИЕ: Если пакет пришел от доверенного DPI-сканера,
        # немедленно прекращаем обработку этой цепочки и переходим к следующей таблице (filter).
        # `return` - это "мягкий" выход, который пропускает пакет дальше по сетевому стеку.
        saddr @dpi_scanners jump log_accepted_mangle return comment "Bypass scan detection for trusted DPI scanners"

        # NAT ПРАВИЛО: Пропускаем трафик от доверенных NAT в обход защиты от флуда (т.к. за одним IP может находиться множество пользователей)
        saddr @trusted_nats counter jump log_accepted_mangle return comment "Bypass flood protection for trusted corporate NATs"

        # ЗАЩИТА ОТ ФЛУДА (DDoS Mitigation) - на уровне TCP-сессий (более "умное")
        # Ограничение новых TCP-соединений. Нужно администратору "осознать" эти значения и подобрать. Если будут вопросы, задавайте, обсудим.
        # --- Как "осознать" эти значения и ввести их в эксплуатацию?
        # Раскомментируйте правила, установите сначала дефолтные лимиты в файле /etc/nftables.d/definitions-services.nft
        # для переменных conn_flood_rate и conn_flood_burst 
        # Включите логирование: 
        # ct state new limit rate over $conn_flood_rate burst $conn_flood_burst log prefix "SYN-FLOOD-THRESHOLD-EXCEEDED: " level warn
        # Наблюдайте: В течение нескольких дней наблюдайте за логами. Если вы видите срабатывания, увеличте лимиты, продолжайте наблюдать.
        # sudo journalctl -g "SYN-FLOOD-THRESHOLD-EXCEEDED:"
        # Лог онлайн: sudo journalctl -fk -g "SYN-FLOOD-THRESHOLD-EXCEEDED:"
        # Лог за последний час: sudo journalctl --since "1 hour ago" -g "SYN-FLOOD-THRESHOLD-EXCEEDED:"
        # Лог за вчерашний день: sudo journalctl --since "yesterday" --until "today" -g "SYN-FLOOD-THRESHOLD-EXCEEDED:"
        # ...
        # После определения количества пакетов закомментирйте предыдущее правило и раскомментирйте следующее:
        # Первые conn_flood_rate соединений в секунду от одного IP проходят это правило,
        # все, что СВЕРХ этого лимита, отбрасываются.
        # ct state new limit rate over $conn_flood_rate burst $conn_flood_burst packets counter jump log_dropped_mangle drop comment "Rate-limit and drop excessive new connections"

        # Универсальная защита от некорректных TCP-пакетов
        # Отбрасываем фрагментированные пакеты, которые НЕ являются частью установленного соединения
        ip frag-off & 0x1fff != 0 ct state != established counter jump log_dropped_mangle drop comment "Drop non-established fragments"

        ct state new tcp flags & (syn|ack|rst|fin) != syn counter jump log_dropped_mangle drop comment "Drop invalid new TCP connection attempts"
        tcp flags & (fin|syn|rst|psh|ack|urg) == 0x0 counter jump log_dropped_mangle drop comment "Drop NULL packet"
        tcp flags & (fin|syn|rst|psh|ack|urg) == (fin|syn|rst|psh|ack|urg) counter jump log_dropped_mangle drop comment "Drop XMAS packet"

        # Блокируем пакеты с бессмысленными комбинациями флагов.
        # Некоторые комбинации TCP-флагов технически не запрещены, но абсолютно бессмысленны в реальном мире и почти всегда указывают на попытку сканирования или обхода файрвола.
        tcp flags & (syn|fin) == (syn|fin) counter jump log_dropped_mangle drop comment "Drop SYN+FIN"
        tcp flags & (syn|rst) == (syn|rst) counter jump log_dropped_mangle drop comment "Drop SYN+RST"

        # Защита от уязвимостей
        ct state new tcp option maxseg size 1-535 counter jump log_dropped_mangle drop comment "Block tiny MSS (SACK Panic Protection)"
        
        jump log_accepted_mangle
    }
}
EOF

cat <<EOF >/etc/nftables.d/netdev.nft
# Назначение: Реализует первый и самый быстрый эшелон защиты (L2/L3),
# работая на уровне сетевого драйвера.
#
# Ключевая идея: Отбрасывать очевидно вредоносный или нежелательный трафик
# (DDoS-флуд, забаненные IP, спуфинг) с минимальными затратами ресурсов,
# до того как он попадет в основной сетевой стек.
#
# Правило для администраторов: Редактируется для тюнинга параметров защиты от DDoS
# и управления "жесткими" блокировками IP-адресов в сете 'netdev_blackhole'
# (хотя это чаще делается через командную строку).

# Создаем таблицу семейства 'netdev' для самой ранней фильтрации.
table netdev ddos {
    # ПУСТАЯ ЦЕПОЧКА ДЛЯ ЛОГИРОВАНИЯ
    # Позволит динамически включать логирование того, что блокируется на этом уровне.
    chain log_dropped_netdev {}
    chain log_accepted_netdev {}

    # Главная цепочка, привязанная к хуку 'ingress'.
    # В этой цепочке происходит самая ранняя фильтрация на уровне драйвера.
    # Ядру уже известны IP-адреса, но еще нет информации о состоянии соединения (conntrack).
    # Поэтому здесь нельзя использовать 'ct state', но можно эффективно блокировать по IP.
    chain ingress {
        # 1. Привязываемся ко ВСЕМ интерфейсам, кроме loopback.
        # Это делает конфигурацию универсальной.
        type filter hook ingress device != "lo" priority -500; policy accept;

        # Логирование разрешенных пакетов
        # Включить:
        # sudo nft add rule netdev ddos log_accepted_netdev counter log prefix "[NETDEV:ACCEPTED] "
        # Выключить:
        # sudo nft flush chain netdev ddos log_accepted_netdev
        # Логирование отброшенных пакетов
        # Включить:
        # sudo nft add rule netdev ddos log_dropped_netdev counter log prefix "[NETDEV:DROPPED] "
        # Выключить:
        # sudo nft flush chain netdev ddos log_dropped_netdev

        # Если интерфейс, на который пришел пакет, НЕ входит в сет `protected_interfaces`,
        # (файл definitions-services.nft)
        # то прекращаем обработку этой цепочки и пропускаем пакет дальше.
        # Это гарантирует, что агрессивные правила ниже применяются ТОЛЬКО к внешним интерфейсам.
        iifname != @protected_interfaces counter jump log_accepted_netdev return comment "Skip DDoS protection for non-protected interfaces"

        # ПРАВИЛО-ИСКЛЮЧЕНИЕ: Не применяем лимиты к доверенным DPI-сканерам.
        saddr @dpi_scanners counter jump log_accepted_netdev return comment "Bypass flood protection for trusted DPI scanners"

        # NAT ПРАВИЛО: Пропускаем трафик от доверенных NAT в обход защиты от флуда
        saddr @trusted_nats counter jump log_accepted_netdev return comment "Bypass flood protection for trusted corporate NATs"

        # ПРАВИЛО: Ограничение ICMP-флуда
        # Ограничиваем количество ICMP-пакетов ОТ КАЖДОГО ИСТОЧНИКА до 1 в секунду (можно изменить через переменную).
        # Это эффективно отразит атаку типа "ping flood".
        meta l4proto icmp limit rate over $icmp4_flood_rate burst $icmp4_flood_burst counter jump log_dropped_netdev drop comment "Rate-limit per-IP ICMP flood at ingress"
        meta l4proto icmpv6 icmpv6 type echo-request limit rate over $icmp6_flood_rate burst $icmp6_flood_burst counter jump log_dropped_netdev drop comment "Rate-limit per-IP ICMPv6 flood at ingress"

        # Проверяем, не заблокирован ли IP-адрес полностью в сете blackhole_ips.
        saddr @blackhole_ips counter jump log_dropped_netdev drop comment "Drop traffic from fully blacklisted IPs"

        # Защита от спуфинга
        iifname != "lo" saddr { 127.0.0.0/8, "::1/128" } counter drop comment "Drop spoofed loopback addresses"
        iifname != "lo" ip saddr @spoofed_privates_subnets counter jump log_dropped_netdev drop comment "Drop spoofed private/reserved subnet"

        # ЗАЩИТА ОТ ФЛУДА (DDoS Mitigation)
        # Грубое ограничение TCP SYN-флуда на всем интерфейсе.
        # Это первая, самая быстрая линия обороны.
        # Ограничиваем количество SYN-пакетов ОТ КАЖДОГО IP ИСТОЧНИКА до 10 в секунду (можно изменить через переменную).
        # Это более "умная" защита, чем общее ограничение на интерфейс.
        tcp flags syn limit rate over $syn_flood_rate burst $syn_flood_burst packets counter jump log_dropped_netdev drop comment "Rate-limit per-IP SYN flood at ingress"

        # Передаем управление на цепочку логирования. Если она пуста, ничего не произойдет.
        # Если в ней есть правила, они сработают на пакеты, которые не были отброшены выше.
        jump log_accepted_netdev
    }
}
EOF

cat <<EOF >/etc/nftables.d/forward-services.nft
# Файл: /etc/nftables.d/forward-services.nft (ОПЦИОНАЛЬНЫЙ ФАЙЛ)
#
# Назначение: Содержит расширенные правила для цепочки `forward`,
# необходимые для работы сред контейнеризации (Docker, Kubernetes), NAT и пр.
#
# ВНИМАНИЕ: Этот файл должен применяться ТОЛЬКО на хостах,
# где действительно используется маршрутизация.

table inet filter {
    # Мы "дополняем" уже существующую цепочку `forward` из `tables.nft`.
    # `flush` гарантирует, что мы заменяем базовое правило на более сложное.
    flush chain forward

    # Цепочка для транзитного трафика (сервер как роутер).
    chain forward {
        # `policy drop`: Критически важно! Запрещает серверу пересылать трафик по умолчанию.
        type filter hook forward priority 0; policy drop;

        # --- ДИНАМИЧЕСКОЕ ЛОГИРОВАНИЕ ТРАФИКА ---
        # Включаем логирование разрешенного транзитного трафика
        # sudo nft add rule inet filter log_accepted_forward counter log prefix "[FORWARD:ACCEPTED] "
        # Включаем логирование заблокированного транзитного трафика
        # sudo nft add rule inet filter log_dropped_forward counter log prefix "[FORWARD:DROPPED] "
        # Пытаемся запустить `apt update` в контейнере и смотрим логи
        # sudo journalctl -fk | grep "FORWARD:DROPPED"

        # --- ОБЩЕЕ ПРАВИЛО ДЛЯ ВСЕХ КОНТЕЙНЕРНЫХ СРЕД ---
        # Это самое важное правило. Оно разрешает обратный трафик для уже установленных
        # соединений. Без него ни один контейнер не сможет получить ответ из интернета.
        ct state related,established counter accept comment "Allow return traffic for established connections"

        # --- ДИНАМИЧЕСКОЕ ЛОГИРОВАНИЕ РАЗРЕШЕННОГО ТРАФИКА ---
        # Позволяет отлаживать, какой именно транзитный трафик разрешен.
        jump log_accepted_forward

        # =================================================================================
        # ===                ПРАВИЛА ДЛЯ DOCKER (выберите нужные)                      ===
        # =================================================================================
        #
        # ПРИМЕЧАНИЕ: Имена интерфейсов могут отличаться. Проверьте их командой `ip a`.
        # "eth0" - имя вашего основного внешнего интерфейса.
        # "docker0" - стандартное имя моста (bridge) Docker.
        #
        # --- Разрешаем контейнерам Docker выходить в интернет ---
        # iifname "docker0" oifname "eth0" counter jump log_accepted_forward accept
        #
        # --- Разрешаем трафику извне попадать в контейнеры через опубликованные порты (-p) ---
        # iifname "eth0" oifname "docker0" counter jump log_accepted_forward accept
        #
        # --- Разрешаем контейнерам общаться друг с другом через мост docker0 ---
        # iifname "docker0" oifname "docker0" counter jump log_accepted_forward accept


        # =================================================================================
        # ===              ПРАВИЛА ДЛЯ KUBERNETES (выберите нужные)                    ===
        # =================================================================================
        #
        # ВАЖНО: Имена интерфейсов в Kubernetes СИЛЬНО ЗАВИСЯТ от используемого CNI-плагина
        # (Calico, Flannel, Cilium и т.д.). Приведенные ниже имена - это ЧАСТЫЕ ПРИМЕРЫ.
        # Обязательно проверьте актуальные имена командой `ip a` на вашем узле кластера.
        #
        # "cni0"    - частое имя для основного моста CNI.
        # "flannel.1" - интерфейс, создаваемый Flannel.
        # "cali+"   - маска для интерфейсов, создаваемых Calico (например, cali123456789). `+` - это wildcard.
        #
        # --- Разрешаем подам выходить в интернет ---
        # iifname "cni0" oifname "eth0" counter jump log_accepted_forward accept
        #
        # --- Разрешаем трафику извне попадать в поды через сервисы (NodePort, LoadBalancer) ---
        # iifname "eth0" oifname "cni0" counter jump log_accepted_forward accept
        #
        # --- Разрешаем межподовое общение (Pod-to-Pod) ---
        # Для Calico:
        # iifname "cali+" oifname "cali+" counter jump log_accepted_forward accept
        #
        # Для многих других CNI через мост:
        # iifname "cni0" oifname "cni0" counter jump log_accepted_forward accept

        jump log_dropped_forward
    }
}
EOF

cat <<EOF >/etc/nftables.d/tables-services.nft
# Файл: /etc/nftables.d/tables-services.nft (ОПЦИОНАЛЬНЫЙ ФАЙЛ)
#
# Назначение: Содержит специфические правила для определенных ролей серверов
# (например, балансировщики, кластерные узлы, NAT).
#
# ВНИМАНИЕ: Этот файл создается и наполняется администратором ТОЛЬКО на тех
# серверах, где требуется эта дополнительная функциональность.

table inet filter {
    # Мы "наполняем" пустую цепочку, определенную в tables.nft.
    chain custom_input_rules {
        # ПРИМЕР для БАЛАНСИРОВЩИКА (Keepalived, CARP)
        # Разрешает протокол IGMP, необходимый для работы некоторых
        # протоколов отказоустойчивости и multicast.
        # ip protocol igmp jump log_accepted_input accept comment "Allow IGMP for Load Balancer role"

        # ПРИМЕР для КЛАСТЕРА (VRRP, например Keepalived)
        # Разрешает протокол VRRP, используемый для виртуальных роутеров.
        # ip protocol vrrp jump log_accepted_input accept comment "Allow VRRP for Cluster role"
    }
}

# Для работы NAT нужна отдельная таблица ip nat.
# table ip nat {
#     chain postrouting {
#         type nat hook postrouting priority 100; policy accept;
#
#         # Пример: Маскарадинг для сети 172.17.0.0/16, выходящих через eth0
#         oifname "eth0" ip saddr 172.17.0.0/16 masquerade
#     }
# }
EOF

cat <<EOF >/etc/nftables.d/raw-optimizations.nft
# Назначение: Оптимизация производительности путем отключения отслеживания соединений
# ('conntrack') для определенного трафика.
#
# Ключевая идея: Для высокочастотного траста (например, DNS, NTP), где каждое соединение состоит
# из одного-двух пакетов, накладные расходы на 'conntrack' могут быть избыточны.
# Действие notrack говорит ядру не тратить на это ресурсы.
#
# Правило для администраторов: Этот файл требует редактирования, если не появляется новый
# высокопроизводительный сервис, для которого нужна подобная оптимизация.

table inet raw {
    chain raw_prerouting {
        # Для серверов предоставляющих сервис DNS
        #udp dport domain notrack
        #tcp dport domain notrack
        # Для серверов предоставляющих сервис NTP
        #udp dport ntp notrack
        #tcp dport ntp notrack
        #
        # Следующие оптимизации имеют смысл только для серверов, обслуживающих очень большое количество коротких транзакций (сотни и тысячи в секунду). Для обычного сервера, который является клиентом этих сервисов, notrack не нужен и может усложнить отладку
        # NFS v3, v4 не использует UDP
        #udp dport nfs notrack
        #tcp dport nfs notrack
        # Для серверов предоставляющих сервис DHCP
        #udp dport bootps notrack
        #tcp dport bootps notrack
        # Для серверов предоставляющих сервис загрузки из сети PXE
        #udp dport tftp notrack
        #tcp dport tftp notrack

        # Пример для одного сервера с предоставлением нескольких сервисов.
        # udp dport { domain, bootps, tftp, ntp, nfs} notrack
        # tcp dport { domain, bootps, tftp, ntp, nfs} notrack
    }
}
EOF
```