## Введение в nftables: Современный файрвол для Linux

`nftables` — это современный фреймворк для фильтрации пакетов в ядре Linux, пришедший на смену устаревшей экосистеме `iptables`. Это не просто "новая версия", а полностью переработанная подсистема, созданная для решения проблем производительности, синтаксиса и сложности, присущих `iptables`.

Основная идея `nftables` — предоставить единый, гибкий и высокопроизводительный инструмент для управления всеми аспектами сетевой безопасности, от простой фильтрации на хосте до сложной маршрутизации и NAT. Вместо набора отдельных утилит (`iptables`, `ip6tables`, `arptables`, `ebtables`) теперь есть единый инструмент командной строки — `nft`.

### Почему nftables? Сравнение с iptables, firewalld и ufw

Чтобы понять преимущества `nftables`, важно сравнить его с другими популярными инструментами.

#### `nftables` vs. `iptables` (Прямой конкурент)

| Характеристика         | `iptables`                                                                                                                                                                                                                               | `nftables`                                                                                                                                                                                                                                                              | Преимущество `nftables`                                                                                                     |
| :--------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------- |
| **Архитектура**        | Набор отдельных утилит (`iptables`, `ip6tables`, `arptables`) со своей логикой.                                                                                                                                                          | Единый фреймворк и утилита `nft` для всех протоколов.                                                                                                                                                                                                                   | **Простота и консистентность.** Больше не нужно переключаться между разными утилитами для IPv4, IPv6 и ARP.                 |
| **Синтаксис**          | Громоздкий, многословный, часто требует повторения правил.                                                                                                                                                                               | Интуитивно понятный, структурированный, похожий на язык программирования.                                                                                                                                                                                               | **Читаемость и удобство.** Правила легче писать, читать и отлаживать.                                                       |
| **Производительность** | **Низкая.** Правила обрабатываются как длинный **линейный список**. Каждый пакет должен последовательно пройти через множество правил, пока не найдется совпадение. Это сильно замедляет работу при большом количестве правил.           | **Высокая.** Использует современные структуры данных, такие как **хэш-таблицы (`map`) и наборы (`set`)**. Проверка на соответствие в сете или карте — это одна быстрая операция, которая не зависит от количества элементов. Это на порядки быстрее линейного перебора. | **Скорость.** `nftables` значительно производительнее, особенно на высоконагруженных системах и при сложных наборах правил. |
| **Обновление правил**  | **Неатомарное.** Применение нового набора правил происходит путем удаления старых и добавления новых по одному. Существует короткий промежуток времени, когда файрвол находится в неконсистентном состоянии, что может быть небезопасно. | **Атомарное.** Весь набор правил применяется как единая транзакция. Либо вся конфигурация успешно применяется, либо не применяется ничего. Это исключает "гонки состояний" и гарантирует целостность.                                                                   | **Надежность и безопасность.**                                                                                              |

#### `nftables` vs. `firewalld` и `ufw` (Разные уровни абстракции)

Часто возникает путаница, но `nftables` не является прямым конкурентом `firewalld` или `ufw`.

- **`nftables`** — это **низкоуровневый фреймворк** в ядре. Это "двигатель" файрвола.
- **`firewalld` и `ufw`** — это **высокоуровневые утилиты управления** (фронтенды). Это "приборная панель" для управления двигателем.

**firewalld:**

- **Что это:** Мощный демон для управления файрволом, использующий концепцию "зон" (например, `public`, `internal`, `dmz`).
- **Связь с `nftables`:** В современных дистрибутивах (RHEL 8+, Fedora, Debian 11+) `firewalld` по умолчанию использует `nftables` в качестве своего **бэкенда**. Он переводит свои высокоуровневые команды (например, `firewall-cmd --zone=public --add-service=http`) в правила `nftables`.
- **Когда использовать:** Идеально подходит для серверов и рабочих станций, где требуется динамическое управление правилами и простая работа с зонами.

**ufw (Uncomplicated Firewall):**

- **Что это:** Очень простой интерфейс для управления файрволом, созданный для максимального упрощения базовых задач (открыть/закрыть порт).
- **Связь с `nftables`:** Также может использовать `nftables` в качестве бэкенда.
- **Когда использовать:** Идеально подходит для персональных компьютеров или простых серверов, где не требуется сложная логика, а нужна лишь базовая защита.

### Как проверить, что в системе используется `nftables`?

Даже если вы используете команды `iptables`, ваша система, скорее всего, уже переводит их в `nftables`. Самый надежный способ это проверить — посмотреть на версию утилиты `iptables`:

```bash
sudo iptables --version
```

- Если вывод содержит `(nf_tables)` — ваша система использует современный режим совместимости. Все команды `iptables` транслируются в `nftables`.
  ```
  iptables v1.8.7 (nf_tables)
  ```
- Если вывод содержит `(legacy)` — ваша система использует старый `iptables`.
  ```
  iptables v1.8.7 (legacy)
  ```

В большинстве современных дистрибутивов Linux по умолчанию используется `iptables-nft`.

### Архитектура `nftables`: Таблицы и Цепочки

Вся логика в `nftables` строится вокруг иерархии: **Таблица -> Цепочка -> Правило**.

- **Таблица (Table):** Контейнер верхнего уровня, группирующий цепочки по семейству протоколов.
- **Цепочка (Chain):** Контейнер для правил. Бывают двух типов:
  - **Базовые цепочки (Base Chains):** "Прикреплены" к точкам входа (хукам) в сетевом стеке ядра.
  - **Пользовательские цепочки (Regular Chains):** Используются для группировки правил и вызываются из других цепочек (`jump`).

#### Основные таблицы и их базовые цепочки (хуки)

| Семейство / Таблица | Описание                                                                        | Базовые цепочки (точки входа)                             | Назначение цепочек                                                                                                                            |
| :------------------ | :------------------------------------------------------------------------------ | :-------------------------------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------- |
| **`arp`**           | Обрабатывает пакеты протокола ARP (L2).                                         | `input`, `output`                                         | Для фильтрации ARP-запросов/ответов.                                                                                                          |
| **`ip`**, **`ip6`** | Обрабатывают только IPv4 или IPv6 соответственно.                               | `prerouting`, `input`, `forward`, `output`, `postrouting` | Раздельное управление трафиком IPv4 и IPv6.                                                                                                   |
| **`inet`**          | **Универсальная.** Обрабатывает и IPv4, и IPv6.                                 | `prerouting`, `input`, `forward`, `output`, `postrouting` | **Рекомендуется использовать** для создания единых правил для обоих протоколов.                                                               |
| **`bridge`**        | Обрабатывает трафик, проходящий через мост (L2).                                | `prerouting`, `input`, `forward`, `output`, `postrouting` | Для фильтрации на уровне L2 в виртуализированных средах или на свитчах.                                                                       |
| **`netdev`**        | **Самый ранний уровень.** Обрабатывает трафик на уровне драйвера сетевой карты. | `ingress`                                                 | Для очень ранней отбраковки пакетов еще до того, как они попадут в основной сетевой стек. Максимальная производительность для защиты от DDoS. |

#### Описание базовых цепочек (порядок прохождения пакета)

1.  **`ingress` (Таблица `netdev`):** Самая первая точка входа пакета в систему, сразу на уровне сетевого драйвера.
2.  **`prerouting` (Таблицы `ip`, `inet`):** Пакет вошел в основной сетевой стек, но ядро еще не приняло решение о маршрутизации (не решено, предназначен ли пакет локальному процессу или его нужно переслать дальше).
3.  **Далее пакет идет по одному из двух путей:**
    - **`input` (Таблицы `ip`, `inet`):** Если пакет предназначен для локального процесса на этом сервере.
    - **`forward` (Таблицы `ip`, `inet`):** Если пакет предназначен другому хосту, этот сервер должен выступить в роли маршрутизатора или используется контейнеризация.
4.  **`output` (Таблицы `ip`, `inet`):** Обрабатывает пакеты, которые сгенерированы локальными процессами на самом сервере.
5.  **`postrouting` (Таблицы `ip`, `inet`):** Последняя точка перед отправкой пакета в сеть. Решение о маршрутизации уже принято. Идеальное место для NAT (маскарадинга).

## Создание конфигурационных файлов nftables

### Описание файлов

### Файл `definitions.nft`: Центр Управления Доступом

Этот файл — сердце и мозг всей нашей конфигурации файрвола. Его можно представить как "базу данных" или "панель управления", в то время как остальные файлы (`tables.nft`, `mangle.nft`) — это "двигатель", который использует данные из этой панели.

#### Основная философия

Мы придерживаемся принципа **"данные отдельно от логики"**.

- **Логика** (`tables.nft`): Описывает _как_ пакеты проходят через систему (например, "сначала проверь `established`, потом `DPI`, потом основную политику..."). Эта логика сложна и меняется редко.
- **Данные** (`definitions.nft`): Описывают _что_ конкретно разрешено или запрещено (например, "IP-адрес `10.10.10.5` может подключаться к порту `5432` по `TCP`"). Эти данные меняются постоянно в ходе обычной эксплуатации.

Разделение этих двух сущностей позволяет нам изменять политики доступа, не затрагивая сложную и отлаженную логику файрвола, что делает систему стабильной и легкой в сопровождении.

#### Структура файла

Файл содержит определения двух типов объектов:

1.  **`set` (Сеты/Наборы):**

    - **Что это:** Простые списки элементов одного типа (например, список IP-адресов).
    - **Примеры у нас:**
      - `blackhole_ips`: "Черный список" для полной блокировки IP.
      - `dpi_scanners`: "Белый список" для доверенных сканеров.
      - `tmp_input_policy`: Динамический список для временного входящего доступа.
    - **Когда использовать:** Когда нужно сгруппировать несколько однотипных элементов для применения к ним одного правила.

2.  **`map` (Карты/Словари):**
    - **Что это:** Более сложная структура "ключ -> значение". Она позволяет создавать точные сопоставления.
    - **Примеры у нас:**
      - `input_policy_map`: Наша основная карта доступа. Она сопоставляет ключ (тройку "IP.протокол.порт") со значением (`accept`).
      - `output_policy_map`: Аналогично, но для исходящего трафика.
    - **Когда использовать:** Когда нужно реализовать детальную политику доступа (Access Control List - ACL).

#### Рабочий процесс для администратора

**Если вам нужно:**

- **Открыть постоянный доступ к новому сервису:**

  1.  Откройте `/etc/nftables.d/definitions.nft`.
  2.  Найдите нужную карту (`input_policy_map` для входящего, `output_policy_map` для исходящего).
  3.  Добавьте новую строку в секцию `elements`, указав IP, протокол, порт и вердикт `accept`.

- **Дать временный доступ разработчику:**

  1.  Не редактируйте файлы.
  2.  Используйте команду `nft add element ...`, чтобы добавить запись в соответствующий `tmp_*_policy` сет с указанием таймаута.

- **Заблокировать атакующий IP:**
  1.  Не редактируйте файлы.
  2.  Используйте команду `nft add element ...`, чтобы добавить IP в `blackhole_ips` или `blackhole_services`.

**Вайжно!:** Этот файл — ваш главный рабочий инструмент. Понимание его структуры — это ключ к эффективному и безопасному управлению файрволом.

### Файл `tables.nft`: Каркас и Логика Файрвола

Если `definitions.nft` — это "база данных" нашего файрвола, то `tables.nft` — это его **"логическая схема" или "блок-схема"**. Он описывает путь, который проходит каждый сетевой пакет, и на каких "перекрестках" принимаются решения.

#### Основная философия

Этот файл отвечает на вопрос **"КАК?"**, а не "ЧТО?". Он определяет последовательность шагов, которые применяются к трафику, и является фундаментом, на котором строятся все остальные правила.

#### Структура файла

Файл разделен на три основные секции, каждая из которых создает свою **таблицу**. Таблицы обрабатываются ядром в строгом порядке: `raw` -> `mangle` -> `filter`.

1.  **`table inet raw`:**

    - **Назначение:** Предварительная обработка.
    - **Задача:** Основная задача — исключить определенный трафик из системы отслеживания соединений (`conntrack`) с помощью действия `notrack`. Это делается для оптимизации на высоконагруженных системах (например, для DNS).
    - **Когда срабатывает:** Самый первый этап в сетевом стеке L3.

2.  **`table inet mangle`:**

    - **Назначение:** Модификация и пред-фильтрация.
    - **Задача:** Здесь мы можем изменять заголовки пакетов. Однако в нашей конфигурации эта таблица используется как второй, более интеллектуальный уровень защиты, где отбрасываются пакеты с аномалиями, требующие анализа L4 (например, некорректные TCP-флаги).
    - **Когда срабатывает:** Сразу после `raw`, до основной фильтрации.

3.  **`table inet filter`:**
    - **Назначение:** **Основная фильтрация.**
    - **Задача:** Это "сердце" нашего файрвола. Здесь принимаются окончательные решения `accept` (принять) или `drop` (отбросить) на основе политик из `definitions.nft`. Файл определяет четыре ключевые **базовые цепочки**:
      - `prerouting`: Обрабатывает пакеты до принятия решения о маршрутизации. У нас здесь применяются правила блокировки.
      - `input`: Обрабатывает трафик, предназначенный **самому серверу**. Здесь находится наша основная логика доступа.
      - `forward`: Обрабатывает транзитный трафик (для Docker/Kubernetes).
      - `output`: Обрабатывает исходящий трафик, сгенерированный **самим сервером**.

**Важно:** В этом файле активно используется команда `jump`. Она работает как "вызов функции" и передает управление пакета в другую цепочку (например, в `mangle_prerouting` или `log_dropped_input`), что позволяет нам сохранять основную логику чистой и модульной.

### Файл `mangle.nft`: Интеллектуальная Защита (L4)

Этот файл можно представить как **службу безопасности, которая проверяет "документы" (заголовки) пакетов** на корректность и выявляет подозрительное поведение. Он работает после `netdev` и `raw`, применяя более глубокий, но и более "дорогой" с точки зрения ресурсов, анализ.

#### Основная философия

Задача `mangle` — отфильтровать трафик, который не является очевидно вредоносным (как поддельный IP), но имеет признаки аномалии или попытки сканирования. Многие правила здесь требуют доступа к **системе отслеживания соединений (`conntrack`)**, поэтому их нельзя было разместить на более раннем уровне `netdev`.

#### Что именно мы здесь делаем?

1.  **Исключения для доверенных хостов:** Первым делом мы пропускаем трафик от доверенных сканеров и NAT, чтобы не применять к ним строгие проверки.
2.  **Защита от флуда (второй уровень):** Здесь могут быть размещены правила, которые ограничивают количество **новых соединений** (`ct state new`), а не просто пакетов. Это более точная защита от SYN-флуда.
3.  **Проверка корректности TCP:** Мы проверяем:
    - Что новые TCP-соединения начинаются с правильного SYN-пакета.
    - Что в пакетах нет бессмысленных или вредоносных комбинаций флагов (NULL, XMAS, SYN+FIN и т.д.).
4.  **Защита от уязвимостей:** Мы блокируем пакеты с аномально низким значением MSS, что защищает от известных уязвимостей ядра (например, SACK Panic).

По сути, `mangle` — это наш "санитарный кордон", который пропускает в основную зону фильтрации (`filter`) только корректно сформированный и не вызывающий подозрений трафик.

### Файл `raw.nft`: Оптимизация Производительности

Этот файл выполняет одну, но очень специфическую задачу — **разгрузку системы отслеживания соединений (`conntrack`)**.

### Основная философия

`conntrack` — это мощный механизм, который позволяет файрволу "помнить" о каждом TCP-соединении и UDP-потоке. Это необходимо для stateful-фильтрации (правило `ct state established`). Однако, эта "память" требует ресурсов CPU и оперативной памяти.

Для некоторых протоколов, которые генерируют огромное количество коротких, независимых транзакций (например, DNS-сервер, отвечающий на тысячи запросов в секунду), ведение записей о каждом "соединении" является избыточным.

#### Что именно мы здесь делаем?

С помощью действия **`notrack`** мы говорим ядру: "Для пакетов, идущих на эти порты (DNS, NTP и др.), не создавай запись в `conntrack`".

**Преимущества:**

- **Снижение нагрузки на CPU:** Ядро выполняет меньше работы.
- **Предотвращение переполнения таблицы `conntrack`:** На очень высоконагруженных системах таблица `conntrack` может переполниться, что приведет к отбрасыванию новых легитимных соединений. `notrack` помогает этого избежать.

**Важно:** Трафик, помеченный как `notrack`, всегда будет иметь состояние `untracked`. Это значит, что для него не сработает правило `ct state established`, и для него нужно будет создавать явные разрешающие правила в обе стороны (что не является проблемой для простых протоколов типа DNS). В нашей конфигурации это не требуется, так как мы используем `notrack` только для сервисов, к которым сервер сам обращается (исходящий трафик).

### Файл `netdev.nft`: Первый Бастион Обороны

Этот файл — наш **"передовой рубеж" или "ров с крокодилами"**. Он содержит правила, которые применяются к пакетам в самый первый момент их поступления на сетевой интерфейс, еще до того, как они попадут в сложную систему маршрутизации и фильтрации.

#### Основная философия

Задача `netdev` — выполнять **грубую, но чрезвычайно быструю** фильтрацию. Он отвечает на простые вопросы, не требующие глубокого анализа:

- "Этот IP-адрес в нашем списке на пожизненную блокировку?" -> `drop`.
- "Этот IP-адрес поддельный (спуфинг)?" -> `drop`.
- "С этого IP-адреса не идет ли слишком много пакетов (флуд)?" -> `drop`.

Так как эти проверки происходят на самом раннем этапе (`hook ingress`), отброшенные здесь пакеты потребляют **минимальное** количество ресурсов сервера. Это критически важно для защиты от массированных DDoS-атак.

#### Что именно мы здесь делаем?

1.  **"Жесткая" блокировка:** Используем сет `netdev_blackhole` для блокировки IP-адресов или целых подсетей, которые участвуют в атаках.
2.  **Защита от спуфинга:** Блокируем пакеты с очевидно поддельными адресами (например, с `127.0.0.1`, приходящим извне).
3.  **Исключения для доверенных хостов:** Пропускаем трафик от наших сканеров и корпоративных NAT в обход защиты от флуда.
4.  **Защита от флуда (первый уровень):** Ограничиваем скорость поступления пакетов (например, TCP SYN или ICMP) от каждого источника, чтобы отразить базовые флуд-атаки.

Этот файл — наш главный инструмент для смягчения (mitigation) DDoS-атак и поддержания стабильности сервера под высокой вредоносной нагрузкой.

## Руководство по `set` и `map`

Вся наша политика безопасности построена не на сотнях отдельных правил, а на двух мощных объектах `nftables`: **сетах (`set`)** и **картах (`map`)**. Понимание их назначения и различий — это ключ к эффективному и безопасному управлению файрволом.

### Философия: Данные отдельно от Логики

Мы придерживаемся принципа **"данные отдельно от логики"**.

- **Логика** (файлы `tables.nft`, `mangle.nft` и т.д.): Описывает _КАК_ пакеты проходят через систему (например, "сначала проверь `established`, потом `DPI`, потом основную политику..."). Эта логика сложна, отлажена и меняется редко.
- **Данные** (файл `definitions.nft`): Описывают _ЧТО_ конкретно разрешено или запрещено (например, "IP `10.10.10.5` может подключаться к порту `5432` по `TCP`"). Эти данные меняются постоянно в ходе обычной эксплуатации.

`set` и `map` — это наши инструменты для управления этими "данными".

---

### Часть 1: Сеты (`set`) — Динамические списки и Группы

#### Что это и для чего?

**Сет** — это именованный **список (набор) элементов**. Представьте его как "список гостей", "черный список" или "список временных пропусков". Основная задача сетов в нашей конфигурации — управление **динамическими**, **временными** или **групповыми** правилами.

#### Когда мы их используем?

1.  **Временные блокировки (`blackhole_ips`, `blackhole_services`):**

    - **Задача:** Быстро забанить IP-адрес (целиком или для конкретного порта) на определенное время.
    - **Почему `set`?** Потому что он поддерживает флаг `timeout`, который **автоматически удаляет** элемент по истечении срока.

2.  **Временный доступ (`tmp_input_policy`, `tmp_output_policy`):**

    - **Задача:** Дать временный доступ для отладки или решения оперативной задачи.
    - **Почему `set`?** Опять же, `timeout` гарантирует, что временное правило не станет постоянной дырой в безопасности.

3.  **Группы-исключения (`dpi_scanners`, `trusted_nats`):**
    - **Задача:** Применить особое правило для целой группы хостов (например, "не применять защиту от флуда к этим IP").
    - **Почему `set`?** Это позволяет нам сгруппировать несколько IP в один именованный объект и использовать его в одном правиле, что делает конфигурацию чище.

#### Ключевые возможности: Временные правила и Интервалы

Сеты обладают двумя мощными флагами:

- **`flags timeout`:** Позволяет элементам **автоматически удаляться** по истечении заданного времени. Это наш главный инструмент для временных правил.
- **`flags interval`:** Позволяет сету хранить **диапазоны** как один элемент. Это относится и к IP-адресам, и к портам:
  - **IP-адреса:** Вместо добавления сотен отдельных IP, мы можем добавить целую **подсеть** (например, `10.20.30.0/24`).
  - **Порты:** Вместо добавления множества портов по одному, мы можем добавить **диапазон** (например, `30000-31000` для пассивных портов FTP).

#### Как использовать?

Управление сетами происходит **"на лету" через командную строку**, без перезагрузки сервиса `nftables`. Изменения, сделанные таким образом, **не сохраняются** после перезагрузки, что идеально для временных задач.

- **Просмотр содержимого:** `sudo nft list set inet filter blackhole_ips`
- **Добавление элемента:**
  - _Простой (IP):_ `sudo nft add element inet filter blackhole_ips { 1.2.3.4 }`
  - _Сложный (IP, протокол, порт) с таймаутом:_ `sudo nft add element inet filter tmp_input_policy { 1.2.3.4 . tcp . 8080 timeout 1h }`
  - _С диапазоном портов:_ `sudo nft add element inet filter tmp_input_policy { 1.2.3.4 . udp . 30000-31000 }`
- **Удаление элемента:** `sudo nft delete element inet filter blackhole_ips { 1.2.3.4 }`

---

### Часть 2: Карты (`map`) — Статические политики доступа (ACL)

#### Что это и для чего?

**Карта** — это более сложная и мощная структура, работающая по принципу **"ключ -> значение"**. Представьте ее как "план рассадки на банкете": каждому гостю (ключу) назначено конкретное место (значение). В нашей конфигурации карты — это основной инструмент для реализации **постоянных политик доступа (Access Control Lists)**.

#### Когда мы их используем?

1.  **Основная политика входящего доступа (`input_policy_map`):** Эта карта содержит все **постоянные** правила, описывающие, кто и к каким сервисам на этом сервере может подключаться.
2.  **Основная политика исходящего доступа (`output_policy_map`):** Эта карта описывает все **постоянные разрешенные** исходящие соединения, которые может устанавливать сам сервер.

#### Ключевые особенности

- **Производительность:** `map` реализован как хэш-таблица, что обеспечивает чрезвычайно быстрый поиск. Это идеальный выбор для правил, которые проверяются для каждого пакета.
- **Статичность:** Карты **не поддерживают** флаг `timeout`. Они предназначены для хранения постоянных, а не временных, правил.

#### Как использовать?

Карты содержат **статическую** политику, которая является частью "законодательства" нашего файрвола. Поэтому управление ими происходит через формальную процедуру редактирования файла конфигурации.

1.  **Откройте** файл `/etc/nftables.d/definitions.nft`.
2.  **Найдите** нужную карту (`input_policy_map` или `output_policy_map`).
3.  **Добавьте новую строку** в секцию `elements`. Например, чтобы разрешить новому серверу мониторинга доступ:
    ```diff
      elements = {
          # ... существующие правила ...
          10.10.10.0/24 . tcp . 22 : accept,
    +     # Новый сервер мониторинга
    +     10.10.20.55 . tcp . 9100 : accept,
      }
    ```
4.  **Проверьте синтаксис** перед применением: `sudo nft --check -f /etc/nftables.conf`.
5.  **Примените конфигурацию**, перезагрузив сервис: `sudo systemctl restart nftables.service`.

**Важно:** Технически `nftables` позволяет менять карты из командной строки. Мы **не используем** этот подход, чтобы избежать рассинхронизации между текущими правилами и файлами конфигурации. Все постоянные изменения должны быть задокументированы в `definitions.nft`.

---

### Рекомендации и итог: Когда что выбрать?

| Критерий             | Используйте Сет (`set`)                         | Используйте Карту (`map`)                               |
| :------------------- | :---------------------------------------------- | :------------------------------------------------------ |
| **Задача**           | Сгруппировать элементы для одного правила       | Создать детальную политику "если `ключ`, то `значение`" |
| **Тип правил**       | **Временные**, динамические, исключения         | **Постоянные**, статические, основные ACL               |
| **Управление**       | **Командная строка** (`nft add/delete`)         | **Редактирование файла** `definitions.nft`              |
| **Постоянство**      | Изменения **не сохраняются** после перезагрузки | Изменения **сохраняются**                               |
| **Нужен `timeout`?** | **Да**, это их основное преимущество            | Нет, не поддерживается                                  |
| **Нужны диапазоны?** | **Да**, с флагом `flags interval`               | Нет, ключ должен быть дискретным                        |

## Конфигурационные файлы

```bash
# Создать бекап конфигурационного файла
cp /etc/nftables.conf{,.$(date +"%Y-%m-%d_%H-%M-%S")}

# Создать директорию для конфигурационных файлов
mkdir -p /etc/nftables.d

# Файл, который применится при загрузке nftable
cat <<EOF >/etc/nftables.conf
# Ссылка на официальную документацию Red Hat, полезно для глубокого изучения.
# More documentations: https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/8/html/configuring_and_managing_networking/getting-started-with-nftables_configuring-and-managing_networking

# Полностью очищает все существующие правила в ядре перед загрузкой новых.
# Гарантирует, что применяются только правила из этих файлов, предотвращает дублирование и конфликты.
# Это обязательная первая команда в любом главном файле.
flush ruleset

# Включает файл с определениями (сеты и карты).
# Загружаем все "данные" (списки IP, портов) в первую очередь, чтобы они были доступны для правил в последующих файлах.
# Порядок включения файлов имеет значение!
include "/etc/nftables.d/definitions.nft"

# Включает файл с основной структурой таблиц и цепочек.
include "/etc/nftables.d/tables.nft"

# Включает файл с правилами для таблицы 'netdev'.
include "/etc/nftables.d/netdev.nft"

# Включает файл с правилами для таблицы 'raw'.
include "/etc/nftables.d/raw.nft"

# Включает файл с правилами для таблицы 'mangle'.
include "/etc/nftables.d/mangle.nft"
EOF


cat <<EOF >/etc/nftables.d/definitions.nft
# Назначение: Централизованное хранилище всех динамических и статических "данных", используемых
# правилами файрвола. Этот файл содержит определения всех именованных объектов (`set` и `map`),
# которые реализуют политики доступа и списки блокировок.
#
# Ключевая идея: Разделение "данных" (ЧТО разрешено/запрещено) от "логики" (КАК обрабатывается трафик).
#
# Правило для администраторов: В 99% случаев для изменения политик доступа (открыть/закрыть порт,
# добавить/удалить IP) необходимо редактировать **только этот файл**. Файлы с логикой
# (`tables.nft`, `mangle.nft` и т.д.) редактируются только при изменении самой архитектуры файрвола.

table inet filter {

    # --- Сет для ПОЛНОЙ временной блокировки IP-адресов ---
    set blackhole_ips {
        # Поддерживаемы типа IPv4 и IPv6
        type ipv4_addr, ipv6_addr
        # Флаги: таймаут и поддержка диапазонов портов и подсетей.
        flags timeout, interval
        timeout 1d        # По-умолчанию 24 часа
        # Как использовать:
        # Блокирует ВЕСЬ трафик от 1.2.3.4 на 24 часа.
        # ip4
        # sudo nft add element inet filter blackhole_ips { 1.2.3.4 }
        # ip6
        # sudo nft add element inet filter blackhole_ips { "2001:db8::dead:beef" }
        # Блокируем всю подсеть 10.200.*.*
        # sudo nft add element inet filter blackhole_ips { 10.200.0.0/16 }
    }

    # --- Сет для ТОЧЕЧНОЙ временной блокировки доступа к сервисам ---
    set blackhole_services {
        type { ipv4_addr, ipv6_addr } . l4proto . inet_service
        # Флаги: таймаут и поддержка диапазонов портов и подсетей.
        flags timeout, interval
        timeout 1h        # По-умолчанию 1 час
        # Как использовать:
        # Блокирует трафик от 1.2.3.4 только на TCP-порт 80 на 1 час.
        # sudo nft add element inet filter blackhole_services { 1.2.3.4 . tcp . 80 }
        # sudo nft add element inet filter blackhole_services { "[2001:db8::1]" . tcp . 80 timeout 10h }
    }

    # --- СЕТ для доверенных NAT-адресов, исключенных из-под защиты от флуда ---
    set trusted_nats {
        type ipv4_addr, ipv6_addr
        # Флаги: поддержка диапазонов портов и подсетей.
        flags interval
        elements = {
            # 11.0.0.0,
            # 192.168.30.25,
        }
    }

    # --- Сет для доверенных DPI-сканеров, которым разрешен полный доступ ---
    set dpi_scanners {
        # Тип данных: хранит IPv4-адреса.
        type ipv4_addr, ipv6_addr
        # Флаги: поддержка диапазонов портов и подсетей.
        flags interval
        # Элементы: IP-адреса ваших сканеров уязвимостей.
        elements = {
            10.10.100.5, # Например, сервер Qualys
            10.10.100.6,  # Например, сервер Nessus
            # fe80::1234:5678:9abc:def0, # Пример IPv6-адреса сканера
        }
    }

    # --- Сет для предоставления ВРЕМЕННОГО и ТОЧЕЧНОГО доступа ---
    set tmp_input_policy {
        # Тип данных: хранит тройку "IP-адрес . Протокол . Порт".
        type { ipv4_addr, ipv6_addr } . l4proto . inet_service

        # Флаги: таймаут и поддержка диапазонов портов и подсетей.
        flags timeout, interval
        timeout 1d

        # Как использовать (НОВЫЙ СИНТАКСИС):
        # --- TCP ---
        # sudo nft add element inet filter tmp_input_policy { 1.2.3.4 . tcp . 8080 timeout 1h }
        # --- UDP ---
        # sudo nft add element inet filter tmp_input_policy { 1.2.3.4 . udp . 51820 timeout 4h }
        # sudo nft add element inet filter tmp_input_policy { 1.2.3.4 . udp . 30000-35000 timeout 2d }
    }

    # --- Сет для ВРЕМЕННОГО и ТОЧЕЧНОГО ИСХОДЯЩЕГО доступа ---
    set tmp_output_policy {
        # Тип данных: тройка "IP-адрес НАЗНАЧЕНИЯ . Протокол . Порт"
        type { ipv4_addr, ipv6_addr } . l4proto . inet_service

        # Флаги: таймаут и поддержка диапазонов портов и подсетей.
        flags timeout, interval
        timeout 1h # <-- Для временного исходящего доступа 1 час - хороший таймаут по умолчанию

        # Как использовать:
        # Разрешить серверу обратиться к 1.1.1.1 по TCP на порт 443 на 1 час.
        # sudo nft add element inet filter tmp_output_policy { 1.1.1.1 . tcp . 443 }
    }

    # --- ЕДИНАЯ КАРТА ДОСТУПА ДЛЯ ВСЕХ СЕРВИСОВ (TCP и UDP) ---
    map input_policy_map {
        # Тип ключа: тройка "IP-адрес . Протокол L4 . Порт"
        # Тип значения: вердикт (accept)
        type { ipv4_addr, ipv6_addr } . l4proto . inet_service : verdict

        elements = {
            # --- ИНФРАСТРУКТУРНЫЕ СЕРВИСЫ (которые инициализируют соединения к своим агентам на Вашем сервере) ---
            # Netbackup (TCP)
            10.10.20.21 . tcp . 13782 : accept,
            # Zabbix (TCP)
            10.10.20.10 . tcp . 10050 : accept,
            # VictoriaMetrics - vmagent (TCP)
            10.10.20.20 . tcp . 8429  : accept,

            # SSH для администраторов (TCP)
            10.10.10.0/24 . tcp . 22 : accept,

            # --- ПРИМЕР: DNS-сервер (UDP и TCP) ---
            # Для сервера, который предоставляет DNS-сервис (обычные сервера не предоставляют DNS):
            # 10.0.0.0/8 . udp . 53 : accept,
            # 10.0.0.0/8 . tcp . 53 : accept,

            # --- ПРИМЕР: NTP-сервер (UDP) ---
            # Для сервера, который держит NTP-сервис (обычные сервера не предоставляют NTP):
            # 0.0.0.0/0 . udp . 123 : accept, # NTP часто доступен отовсюду

            # --- БИЗНЕС-СЕРВИСЫ ---
            # Веб-сервер (TCP)
            10.0.0.0/8 . tcp . http : accept,
            10.0.0.0/8 . tcp . https : accept,
            # Веб-сервер (QUIC/HTTP3, UDP)
            10.0.0.0/8 . udp . 443 : accept,

            # PostgreSQL (TCP)
            10.10.10.20 . tcp . 5432 : accept
            10.10.10.21 . tcp . 5432 : accept
        }
    }

    # --- ЕДИНАЯ КАРТА ДЛЯ РАЗРЕШЕННОГО ИСХОДЯЩЕГО ТРАФИКА ---
    map output_policy_map {
        # Тип ключа: тройка "IP-адрес НАЗНАЧЕНИЯ . Протокол L4 . Порт НАЗНАЧЕНИЯ"
        type { ipv4_addr, ipv6_addr } . l4proto . inet_service : verdict

        elements = {
            # --- БАЗОВЫЕ ИНФРАСТРУКТУРНЫЕ СЕРВИСЫ ---
            # 1. DNS: Разрешаем серверу обращаться к DNS-серверам.
            # ПРИМЕЧАНИЕ: Замените на IP ваших корпоративных или публичных DNS-резолверов.
            10.10.10.1 . udp . 53 : accept,
            10.10.10.1 . tcp . 53 : accept,
            # Для ДМЗ: разрешаем ДНС запросы только на яндекс-серверам.
            # 77.88.8.8 . udp . 53 : accept,
            # 77.88.8.1 . tcp . 53 : accept,

            # 2. NTP: Разрешаем синхронизацию времени.
            # ПРИМЕЧАНИЕ: Замените на IP ваших корпоративных или публичных NTP-серверов.
            10.10.10.2 . udp . 123 : accept,
            192.168.1.1 . udp . 123 : accept,

            # 3. Zabbix Agent (Active Checks): Разрешаем агенту отправлять данные на Zabbix-сервер.
            # Zabbix Agent -> Zabbix Server
            10.10.20.10 . tcp . 10051 : accept,

            # --- ОБНОВЛЕНИЯ И ПАКЕТЫ ---
            # 4. Репозитории пакетов (HTTP/HTTPS).
            # ПРИМЕЧАНИЕ: Здесь должны быть IP-адреса ваших зеркал (например, mirror.yandex.ru, vault.centos.org).
            # Это САМАЯ ВАЖНАЯ часть для поддержания системы в рабочем состоянии.
            # Пример для корпоративного зеркала:
            10.10.50.100 . tcp . http : accept,
            10.10.50.100 . tcp . https : accept,
        }
    }
}
EOF


cat <<EOF >/etc/nftables.d/tables.nft
# Назначение: Определяет основную архитектуру и логический поток обработки пакетов.
# Этот файл создает все необходимые таблицы (`raw`, `mangle`, `filter`)
# и базовые цепочки (`prerouting`, `input`, `forward`, `output`).
#
# Ключевая идея: Этот файл является "скелетом" файрвола. Он определяет, в каком порядке
# и на каких этапах ('hook') обрабатывается трафик, и с помощью команд 'jump' делегирует
# специфические задачи другим файлам или цепочкам.
#
# Правило для администраторов: Этот файл редактируется крайне редко.
# Изменения вносятся только в случае фундаментальных изменений в архитектуре
# (например, добавление новой базовой цепочки или изменение политики по умолчанию).

# --- Таблица RAW: Предварительная обработка ---
# Зачем: Используется для исключения трафика из системы отслеживания соединений (conntrack).
table inet raw {
    chain prerouting {
        # filter: тип цепочки; hook prerouting: точка входа (до маршрутизации); priority -300: самый высокий приоритет.
        type filter hook prerouting priority -300; policy accept;
        # Передаем управление пользовательской цепочке, определенной в raw.nft
        jump raw_prerouting
    }
}

# --- Таблица MANGLE: Модификация пакетов ---
# Зачем: Для изменения заголовков пакетов и для ранней отбраковки вредоносных пакетов (сканирование, спуфинг).
table inet mangle {
    chain prerouting {
        # priority -150: выполняется после `raw`.
        type filter hook prerouting priority -150; policy accept;
        # Передаем управление пользовательской цепочке, определенной в mangle.nft
        jump mangle_prerouting
    }
}

# --- Таблица FILTER: Основная фильтрация ---
# inet: работает и для IPv4, и для IPv6.
table inet filter {
    # --- ПУСТЫЕ ЦЕПОЧКИ ДЛЯ ЛОГИРОВАНИЯ ---
    chain log_accepted_input {}
    chain log_accepted_output {}
    chain log_dropped_input {}
    chain log_dropped_output {}
    chain log_accepted_forward {}
    chain log_dropped_forward {}
    chain log_dropped_netdev {}

    chain prerouting {
        type filter hook prerouting priority 0; policy accept;

        # 1. Проверяем, не заблокирован ли доступ к конкретному сервису.
        saddr . meta l4proto . th dport @blackhole_services counter drop comment "Drop traffic to specific blacklisted services"
    }

    # Цепочка для входящего трафика, предназначенного самому серверу.
    chain input {
        # `policy drop`: Политика по умолчанию. "Запрещено всё, что не разрешено явно".
        # Это краеугольный камень безопасности файрвола.
        type filter hook input priority 0; policy drop;

        # --- Основные разрешающие правила ---
        # Разрешает трафик для уже установленных или связанных соединений. Самое важное правило для работы stateful-файрвола.
        ct state related,established counter accept comment "Accept traffic connections"
        # Разрешает любой трафик с/на loopback-интерфейс (lo). Необходимо для работы многих локальных сервисов.
        iifname lo accept comment "Accept any localhost traffic"
        # Отбрасывает пакеты, которые не могут быть идентифицированы системой отслеживания соединений. Защита от некоторых видов атак.
        ct state invalid counter drop comment "Drop in valid connections"
        # Разрешает протокол IGMP (для multicast-трафика). Если небходим - раскомментировать. Обычно используется для потоковых данных (например IPTV) или кластерных систем.
        # ip protocol igmp accept comment "Accept IGMP"

        # ПРАВИЛО-ИСКЛЮЧЕНИЕ: Если пакет пришел от доверенного DPI-сканера,
        # немедленно принимаем его, предоставляя доступ ко всем портам.
        # Это правило должно быть здесь, чтобы обойти все последующие `jump` и политику `drop`.
        saddr @dpi_scanners counter accept comment "Allow all access for trusted DPI scanners"

        # --- Правила для ICMP (ping и служебные сообщения) ---
        # Разрешает критически важные ICMP-сообщения, необходимые для корректной диагностики сети.
        ip protocol icmp icmp type { destination-unreachable, time-exceeded, parameter-problem } accept comment "Accept critical ICMP types"
        # Перенесен в netdev
        ## Разрешает "пинг" (echo-request), но ограничивает его частоту (не более 1 пакета в секунду) для защиты от ICMP-флуда.
        #ip protocol icmp icmp type echo-request limit rate 1/second burst 3 packets accept comment "Rate-limit ICMP echo-request"

        ip6 nexthdr icmpv6 icmpv6 type { destination-unreachable, packet-too-big, time-exceeded, parameter-problem, nd-neighbor-solicit, nd-neighbor-advert, nd-router-solicit, nd-router-advert } accept comment "Accept critical ICMPv6 types"
        # Перенесен в netdev
        ## Разрешает "пинг" для IPv6 с ограничением скорости.
        #ip6 nexthdr icmpv6 icmpv6 type echo-request limit rate 1/second burst 3 packets accept comment "Rate-limit ICMPv6 echo-request"

        # Включить логирование разрешенного входящего трафика. В примере логируем разрешенный входящий трафик на 22 порт.
        # sudo nft add rule inet filter log_accepted_traffic meta l3proto {ip, ip6} ip saddr . meta l4proto . th dport @input_policy_map tcp dport 22 counter log prefix "[INPUT-22:ACCEPTED] " level info
        # Выключить логирование (просто очистить цепочку):
        # sudo nft flush chain inet filter log_accepted_traffic
        jump log_accepted_input

        # --- Переход к правилам для сервисов ---
        # ЕДИНОЕ ПРАВИЛО ДОСТУПА ДЛЯ ВСЕХ СЕРВИСОВ (TCP и UDP)
        # Это правило берет IP источника, протокол L4 и порт назначения из пакета
        # и ищет их комбинацию в нашей единой карте доступа.
        # `th dport` - это "transport header destination port", работает и для TCP, и для UDP.
        saddr . meta l4proto . th dport @input_policy_map counter accept comment "Allow services based on the unified access policy map"

        # Правило для временного TCP-доступа
        saddr . meta l4proto . th dport @tmp_input_policy counter accept comment "Accept for temporary access policy (TCP/UDP)"

        # Включить логирование блокирования
        # sudo nft add rule inet filter log_dropped_input counter log prefix "[INPUT:BLOCKED] " level warn
        # Включить логирование блокированных пакетов на 22 порт
        # sudo nft add rule inet filter log_dropped_input tcp dport 22 counter log prefix "[INPUT-22:BLOCKED] " level warn
        #      посмотреть лог: sudo journalctl -fk | grep "INPUT-22:BLOCKED"
        # Логируем заблокированные пакеты на порт 22, но ТОЛЬКО от источника 1.2.3.4
        # sudo nft add rule inet filter log_dropped_input ip saddr 1.2.3.4 tcp dport 22 counter log prefix "[DEBUG-SSH-BLOCK] "
        # Выключить логирование (просто очистить цепочку):
        # sudo nft flush chain inet filter log_dropped_input
        jump log_dropped_input
    }

    # Цепочка для транзитного трафика (сервер как роутер).
    chain forward {
        # `policy drop`: Критически важно! Запрещает серверу пересылать трафик по умолчанию.
        type filter hook forward priority 0; policy drop;

        # --- ОБЩЕЕ ПРАВИЛО ДЛЯ ВСЕХ КОНТЕЙНЕРНЫХ СРЕД ---
        # Это самое важное правило. Оно разрешает обратный трафик для уже установленных
        # соединений. Без него ни один контейнер не сможет получить ответ из интернета.
        # Раскомментируйте его в первую очередь при работе с Docker или Kubernetes.
        #
        # ct state related,established counter accept

        # --- ДИНАМИЧЕСКОЕ ЛОГИРОВАНИЕ РАЗРЕШЕННОГО ТРАФИКА ---
        # Позволяет отлаживать, какой именно транзитный трафик разрешен.
        jump log_accepted_forward

        # =================================================================================
        # ===                ПРАВИЛА ДЛЯ DOCKER (выберите нужные)                      ===
        # =================================================================================
        #
        # ПРИМЕЧАНИЕ: Имена интерфейсов могут отличаться. Проверьте их командой `ip a`.
        # "eth0" - имя вашего основного внешнего интерфейса.
        # "docker0" - стандартное имя моста (bridge) Docker.
        #
        # --- Разрешаем контейнерам Docker выходить в интернет ---
        # iifname "docker0" oifname "eth0" counter accept
        #
        # --- Разрешаем трафику извне попадать в контейнеры через опубликованные порты (-p) ---
        # iifname "eth0" oifname "docker0" counter accept
        #
        # --- Разрешаем контейнерам общаться друг с другом через мост docker0 ---
        # iifname "docker0" oifname "docker0" counter accept


        # =================================================================================
        # ===              ПРАВИЛА ДЛЯ KUBERNETES (выберите нужные)                    ===
        # =================================================================================
        #
        # ВАЖНО: Имена интерфейсов в Kubernetes СИЛЬНО ЗАВИСЯТ от используемого CNI-плагина
        # (Calico, Flannel, Cilium и т.д.). Приведенные ниже имена - это ЧАСТЫЕ ПРИМЕРЫ.
        # Обязательно проверьте актуальные имена командой `ip a` на вашем узле кластера.
        #
        # "cni0"    - частое имя для основного моста CNI.
        # "flannel.1" - интерфейс, создаваемый Flannel.
        # "cali+"   - маска для интерфейсов, создаваемых Calico (например, cali123456789). `+` - это wildcard.
        #
        # --- Разрешаем подам выходить в интернет ---
        # iifname "cni0" oifname "eth0" counter accept
        #
        # --- Разрешаем трафику извне попадать в поды через сервисы (NodePort, LoadBalancer) ---
        # iifname "eth0" oifname "cni0" counter accept
        #
        # --- Разрешаем межподовое общение (Pod-to-Pod) ---
        # Для Calico:
        # iifname "cali+" oifname "cali+" counter accept
        #
        # Для многих других CNI через мост:
        # iifname "cni0" oifname "cni0" counter accept

        # --- ДИНАМИЧЕСКОЕ ЛОГИРОВАНИЕ ЗАБЛОКИРОВАННОГО ТРАФИКА ---
        # Стоит в конце. Сработает для всего, что не было разрешено выше.
        jump log_dropped_forward
        # Включаем логирование заблокированного транзитного трафика
        # sudo nft add rule inet filter log_dropped_forward counter log prefix "[FORWARD:DROPPED] "
        # Пытаемся запустить `apt update` в контейнере и смотрим логи
        # sudo journalctl -fk | grep "FORWARD:DROPPED"
    }

    # Цепочка для исходящего трафика (от самого сервера).
    chain output {
        # `policy accept`: Стандартная практика для серверов. Разрешает все исходящие соединения.
        #type filter hook output priority 0; policy accept;

        # 1. МЕНЯЕМ ПОЛИТИКУ НА DROP: Запрещаем все исходящие соединения по умолчанию.
        # Это критически важное изменение для реализации egress filtering.
        type filter hook output priority 0; policy drop;

        # 2. РАЗРЕШАЕМ БАЗОВЫЕ ВЕЩИ (ОБЯЗАТЕЛЬНО!)
        # Разрешаем исходящий трафик для уже установленных соединений. Без этого не будет работать ни одно TCP-соединение.
        ct state related,established counter accept comment "Allow established outgoing connections"
        # Разрешаем любой исходящий трафик на loopback-интерфейс.
        oifname lo accept comment "Allow any localhost outgoing traffic"

        # Включить логирование разрешенного исходящего трафика. В примере логируем исходящий трафик на zabbix-сервер
        # sudo nft add rule inet filter log_accepted_output meta l3proto {ip, ip6} ip daddr . meta l4proto . th dport @output_policy_map tcp dport 10051 counter log prefix "[OUTPUT-10051:ACCEPTED] " level info
        # Выключить логирование (просто очистить цепочку):
        # sudo nft flush chain inet filter log_accepted_output
        jump log_accepted_output

        # 3. ИСПОЛЬЗУЕМ КАРТУ ДЛЯ РАЗРЕШЕНИЯ ЛЕГИТИМНОГО ТРАФИКА
        # Это правило проверяет IP назначения, протокол и порт назначения пакета
        # по нашей карте разрешенных исходящих соединений.
        daddr . meta l4proto . th dport @output_policy_map counter accept comment "Allow legitimate outgoing traffic based on egress policy map"

        # 4. НОВОЕ: Правило для ВРЕМЕННОГО исходящего доступа ---
        # Проверяем, соответствует ли пакет временной политике.
        daddr . meta l4proto . th dport @tmp_output_policy counter accept comment "Allow temporary outgoing traffic"

        # Включить логирование блокировки исходящего трафика
        # sudo nft add rule inet filter log_dropped_output counter log prefix "[OUTPUT:BLOCKED] " level warn
        # Включить логирование блокированных пакетов на host 10.10.30.5
        # sudo nft add rule inet filter log_dropped_output tcp daddr 10.10.30.5 counter log prefix "[OUTPUT-10.10.30.5:BLOCKED] " level warn
        #      посмотреть лог: sudo journalctl -fk | grep "OUTPUT-10.10.30.5:BLOCKED"
        # Выключить логирование (просто очистить цепочку):
        # sudo nft flush chain inet filter log_dropped_output
        jump log_dropped_output
    }
}
EOF

cat <<EOF >/etc/nftables.d/mangle.nft
# Назначение: Реализует второй эшелон защиты, фокусируясь на анализе L4-заголовков
# и поведенческих аномалий, которые требуют доступа к 'conntrack'.
#
# Ключевая идея: Отбрасывать некорректно сформированные или подозрительные пакеты
# (например, с неправильными TCP-флагами, аномальным MSS) до того, как они достигнут
# основной логики фильтрации.
#
# Правило для администраторов: Редактируется редко, в основном для тюнинга параметров защиты
# от флуда или добавления новых правил для защиты от уязвимостей L4.

table inet mangle {
    chain mangle_prerouting {
        # ПРАВИЛО-ИСКЛЮЧЕНИЕ: Если пакет пришел от доверенного DPI-сканера,
        # немедленно прекращаем обработку этой цепочки и переходим к следующей таблице (filter).
        # `return` - это "мягкий" выход, который пропускает пакет дальше по сетевому стеку.
        ip saddr @dpi_scanners return comment "Bypass scan detection for trusted DPI scanners"

        # Пренесли в netdev
        ## Защита от спуфинга: пакеты с адресом 127.0.0.0/8 не должны приходить извне.
        #iifname != "lo" ip saddr 127.0.0.0/8 counter drop comment "These rules assume that your loopback interface"
        ## Защита от спуфинга: блокируем пакеты с зарезервированными/частными IP-адресами, если они приходят из интернета.
        #ip saddr { 0.0.0.0/8,169.254.0.0/16,172.16.0.0/12,192.0.2.0/24,224.0.0.0/3,240.0.0.0/5} counter drop comment "Block Packets From Private Subnets (Spoofing)"
        #ip6 saddr { ::1/128, fe80::/10, ff00::/8 } counter drop comment "Drop spoofed IPv6 special networks"

        # NAT ПРАВИЛО: Пропускаем трафик от доверенных NAT в обход защиты от флуда (т.к. за одним IP "сидят" множество пользователей)
        saddr @trusted_nats counter return comment "Bypass flood protection for trusted corporate NATs"

        # ЗАЩИТА ОТ ФЛУДА (DDoS Mitigation) - на уровне TCP-сессий
        # Ограничение новых TCP-соединений. Нужно администратору "осознать" эти значения и подобрать. Если будут вопросы, задавайте, обсудим.
        # --- Как "осознать" эти значения и ввести их в эксплуатацию?
        # Начните с высоких значений: Раскомментируйте правила, но установите щедрые лимиты, например limit rate 100/second burst 200 packets.
        # Включите логирование: Временно добавьте правило для логирования отброшенных пакетов (перед правилосм по ограничению новых TCP-соединений),
        # чтобы видеть, не блокируете ли вы кого-то по ошибке:
        # ct state new log prefix "SYN-FLOOD-DROPPED: " limit rate 100/second burst 200 packets counter drop
        # Наблюдайте: В течение нескольких дней наблюдайте за логами. Если вы не видите ложных срабатываний, можно постепенно снижать лимиты до более разумных значений (10-20/сек — хороший старт для большинства веб-серверов).
        # Уберите логирование: После настройки уберите правило с log, оставив только drop.
        # --- правила по ограничению новых TCP-соединений;
        # ct state new tcp flags & syn != 0 limit rate 10/second burst 20 packets counter accept comment "Rate-limit TCP SYN flood"
        # ct state new counter drop comment "Drop excessive new connections"

        # Универсальная защита от некорректных TCP-пакетов
        ip frag-off & 0x1fff != 0 counter drop comment "Drop fragmented packets"
        ct state new tcp flags & (syn|ack|rst|fin) != syn counter drop comment "Drop invalid new TCP connection attempts"
        tcp flags & (fin|syn|rst|psh|ack|urg) == 0x0 counter drop comment "Drop NULL packet"
        tcp flags & (fin|syn|rst|psh|ack|urg) == (fin|syn|rst|psh|ack|urg) counter drop comment "Drop XMAS packet"

        # Блокируем пакеты с бессмысленными комбинациями флагов.
        # Некоторые комбинации TCP-флагов технически не запрещены, но абсолютно бессмысленны в реальном мире и почти всегда указывают на попытку сканирования или обхода файрвола.
        tcp flags & (syn|fin) == (syn|fin) counter drop comment "Drop SYN+FIN"
        tcp flags & (syn|rst) == (syn|rst) counter drop comment "Drop SYN+RST"

        # Защита от уязвимостей
        ct state new tcp option maxseg size 1-535 counter drop comment "Block tiny MSS (SACK Panic Protection)"
    }
}
EOF

cat <<EOF >/etc/nftables.d/raw.nft
# Назначение: Оптимизация производительности путем отключения отслеживания соединений
# ('conntrack') для определенного трафика.
#
# Ключевая идея: Для высокочастотного траста (например, DNS, NTP), где каждое соединение состоит
# из одного-двух пакетов, накладные расходы на 'conntrack' могут быть избыточны.
# Действие notrack говорит ядру не тратить на это ресурсы.
#
# Правило для администраторов: Этот файл не требует редактирования, если не появляется новый
# высокопроизводительный сервис, для которого нужна подобная оптимизация.

table inet raw {
    chain raw_prerouting {
        # 'notrack': Указывает системе не отслеживать соединения для этих портов.
        # Зачем: Снижает нагрузку на CPU на высоконагруженных серверах, обрабатывающих много мелких пакетов (DNS, NTP).
        # Для большинства серверов это не обязательно, но является хорошей практикой.
        # udp dport { domain, bootps, tftp, ntp, nfs} notrack
        # tcp dport { domain, bootps, tftp, ntp, nfs} notrack
    }
}
EOF

cat <<EOF >/etc/nftables.d/netdev.nft
# Назначение: Реализует первый и самый быстрый эшелон защиты (L2/L3),
# работая на уровне сетевого драйвера.
#
# Ключевая идея: Отбрасывать очевидно вредоносный или нежелательный трафик
# (DDoS-флуд, забаненные IP, спуфинг) с минимальными затратами ресурсов,
# до того как он попадет в основной сетевой стек.
#
# Правило для администраторов: Редактируется для тюнинга параметров защиты от DDoS
# и управления "жесткими" блокировками IP-адресов в сете 'netdev_blackhole'
# (хотя это чаще делается через командную строку).

# Создаем таблицу семейства 'netdev' для самой ранней фильтрации.
table netdev ddos {
    # ПУСТАЯ ЦЕПОЧКА ДЛЯ ЛОГИРОВАНИЯ
    # Позволит нам динамически включать логирование того, что блокируется на этом уровне.
    chain log_dropped_netdev {}

    # Применяем на серверах в DMZ, которые открыты всему интЕрнет. На серверах в DMZ с доступом точка-точка можно не применять.
    # Главная цепочка, привязанная к хуку 'ingress'.
    # ВАЖНО: ЗАМЕНИТЕ "eth0" на имя вашего основного внешнего сетевого интерфейса!
    # В этой цепочке происходит самая ранняя фильтрация на уровне драйвера.
    # Ядру уже известны IP-адреса, но еще нет информации о состоянии соединения (conntrack).
    # Поэтому здесь нельзя использовать 'ct state', но можно эффективно блокировать по IP.
    # Надо проводить анализ
    chain ingress {
        type filter hook ingress device "eth0" priority -500; policy accept;

        # ПРАВИЛО-ИСКЛЮЧЕНИЕ: Не применяем лимиты к доверенным DPI-сканерам.
        saddr @dpi_scanners counter return comment "Bypass flood protection for trusted DPI scanners"
        # NAT ПРАВИЛО: Пропускаем трафик от доверенных NAT в обход защиты от флуда
        saddr @trusted_nats counter return comment "Bypass flood protection for trusted corporate NATs"

        # ПРАВИЛО: Ограничение ICMP-флуда
        # Ограничиваем количество ICMP-пакетов ОТ КАЖДОГО ИСТОЧНИКА до 1 в секунду.
        # Это эффективно отразит атаку типа "ping flood".
        meta l4proto icmp limit rate over 1/second counter drop comment "Rate-limit per-IP ICMP flood at ingress"
        meta l4proto icmpv6 icmpv6 type echo-request limit rate over 5/second counter drop comment "Rate-limit per-IP ICMPv6 flood at ingress"

        # --- ДОБАВЛЯЕМ ДВА ПРАВИЛА БЛОКИРОВКИ ---
        # 1. Проверяем, не заблокирован ли IP-адрес полностью.
        saddr @blackhole_ips counter drop comment "Drop traffic from fully blacklisted IPs"

        # 2. ЗАЩИТА ОТ СПУФИНГА (переехала сюда)
        iifname != "lo" saddr { 127.0.0.0/8, "::1/128" } counter drop comment "Drop spoofed loopback addresses"
        saddr { 0.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, 224.0.0.0/3, 240.0.0.0/5 } counter drop comment "Drop spoofed private/reserved IPv4 subnets"
        ip6 saddr { fe80::/10, ff00::/8 } counter drop comment "Drop spoofed private/reserved IPv6 subnets"

        # --- ЗАЩИТА ОТ ФЛУДА (DDoS Mitigation) ---
        # Грубое ограничение TCP SYN-флуда на всем интерфейсе.
        # Пропускаем не более 1000 новых SYN-пакетов в секунду. Все, что выше - отбрасывается.
        # Это первая, самая быстрая линия обороны.
        # Ограничиваем количество SYN-пакетов ОТ КАЖДОГО IP ИСТОЧНИКА до 10 в секунду.
        # Это более "умная" защита, чем общее ограничение на интерфейс.
        tcp flags syn limit rate over 10/second burst 20 packets counter drop comment "Rate-limit per-IP SYN flood at ingress"

        # Передаем управление на цепочку логирования. Если она пуста, ничего не произойдет.
        # Если в ней есть правила, они сработают на пакеты, которые не были отброшены выше.
        jump log_dropped_netdev
        # Включить:
        # sudo nft add rule netdev ddos log_dropped_netdev counter log prefix "[NETDEV:DROPPED] "
        # Выключить:
        # sudo nft flush chain netdev ddos log_dropped_netdev
    }
}
EOF

```